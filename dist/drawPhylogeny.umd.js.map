{"version":3,"file":"drawPhylogeny.umd.js","sources":["../src/radial/polarToCartesian.js","../src/utils/preorder.js","../src/utils/fortify.js","../src/radial/radialData.js","../src/radial/radialLayout.js","../src/radial/getRadii.js","../src/radial/getArcs.js","../src/radial/getChildArcs.js","../src/rectangle/getHorizontal.js","../src/utils/mean.js","../src/rectangle/rectangleLayout.js","../src/rectangle/getVertical.js","../src/rectangle/getChildVerticals.js","../src/unrooted/equalAngleLayout.js","../src/utils/numTips.js","../src/unrooted/unrooted.js","../src/utils/edges.js","../src/utils/readTree.js","../src/plot/drawPhylogeny.js","../src/radial/describeArc.js"],"sourcesContent":["// src/radial/polarToCartesian.js\nexport default function (cx, cy, r, t) {\n  return { x: cx + r * Math.cos(t), y: cy - r * Math.sin(t) };\n}\n","/**\n * Recursive function for pre-order traversal of tree (returns array)\n */\nexport function preorder(node, list = []) {\n  list.push(node);\n  for (let i = 0; i < (node.children?.length || 0); i++) {\n    list = preorder(node.children[i], list);\n  }\n  return list;\n}\n\n/**\n * Iterative generator traversals (avoid recursion limits on large trees)\n */\nexport function* preorderIter(root) {\n  const stack = [root];\n  while (stack.length) {\n    const n = stack.pop();\n    yield n;\n    if (n.children) for (let i = n.children.length - 1; i >= 0; --i) stack.push(n.children[i]);\n  }\n}\n\nexport function* postorderIter(root) {\n  const stack = [[root, 0]];\n  while (stack.length) {\n    const top = stack[stack.length - 1];\n    const [n, i] = top;\n    if (!n.children || i >= n.children.length) {\n      stack.pop();\n      yield n;\n    } else {\n      top[1] = i + 1;\n      stack.push([n.children[i], 0]);\n    }\n  }\n}\n\n","import { preorder } from \"./preorder.js\"\n\n/**\n * Convert parsed Newick tree from readTree() into data\n * frame.\n * this is akin to a \"phylo\" object in R.\n */\n\nexport default function (tree, sort = true) {\n    var df = [];\n\n    for (const node of preorder(tree)) {\n        if (node.parent === null) {\n            df.push({\n                'parentId': null,\n                'parentLabel': null,\n                'thisId': node.id,\n                'thisLabel': node.label,\n                'children': node.children.map(x => x.id),\n                'branchLength': 0.,\n                'isTip': false,\n                'x': node.x,\n                'y': node.y,\n                'angle': node.angle\n            })\n        }\n        else {\n            df.push({\n                'parentId': node.parent.id,\n                'parentLabel': node.parent.label,\n                'thisId': node.id,\n                'thisLabel': node.label,\n                'children': node.children.map(x => x.id),\n                'branchLength': node.branchLength,\n                'isTip': (node.children.length == 0),\n                'x': node.x,\n                'y': node.y,\n                'angle': node.angle\n            })\n        }\n    }\n\n    if (sort) {\n        df = df.sort(function (a, b) {\n            return a.thisId - b.thisId;\n        })\n    }\n    return (df);\n}\n","import fortify from \"../utils/fortify.js\"\n\n/**\n * Compute per-node polar coordinates for radial layout:\n *  - Tip angles: evenly spaced 0..2π in tip DFS order\n *  - Internal angles: circular mean of child angles\n *  - Radii: cumulative branch length from root\n *  - x,y: cartesian projection\n *\n * Returns the fortified array with added {angle, r, x, y}.\n */\nexport default function radialData(node) {\n  const TAU = Math.PI * 2;\n  const norm = (t) => ((t % TAU) + TAU) % TAU;\n\n  const pd = fortify(node, /*sort*/ true);\n  const byId = new Map(pd.map(d => [d.thisId, d]));\n  const kids = new Map(pd.map(d => [d.thisId, d.children || []]));\n\n  // Find root id\n  let root = null;\n  for (const d of pd) {\n    if (d.parentId == null) { root = d.thisId; break; }\n  }\n\n  // Collect tip ids in DFS left->right order to preserve input ordering\n  const tipIds = [];\n  (function dfs(id) {\n    const c = kids.get(id) || [];\n    if (c.length === 0) {\n      tipIds.push(id);\n      return;\n    }\n    for (const ch of c) dfs(ch);\n  })(root);\n\n  // Assign tip angles evenly spaced 0..2π\n  const N = Math.max(1, tipIds.length);\n  const angle = new Map();\n  tipIds.forEach((id, i) => {\n    angle.set(id, (i / N) * TAU);\n  });\n\n  // Internal node angles: circular mean of child angles (post-order)\n  (function setInternalAngles(id) {\n    const c = kids.get(id) || [];\n    for (const ch of c) setInternalAngles(ch);\n    if (c.length > 0) {\n      let sx = 0, sy = 0;\n      for (const ch of c) {\n        const th = angle.get(ch);\n        sx += Math.cos(th);\n        sy += Math.sin(th);\n      }\n      angle.set(id, norm(Math.atan2(sy, sx)));\n    }\n  })(root);\n\n  // Radii: cumulative branch lengths from root (root r=0)\n  const radius = new Map();\n  radius.set(root, 0);\n  (function setR(id) {\n    const c = kids.get(id) || [];\n    const r0 = radius.get(id) || 0;\n    for (const ch of c) {\n      const child = byId.get(ch);\n      const bl = child?.branchLength ?? 0;\n      radius.set(ch, r0 + bl);\n      setR(ch);\n    }\n  })(root);\n\n  // Enrich pd rows with angle, r, x, y\n  for (const d of pd) {\n    const th = angle.get(d.thisId) ?? 0;\n    const r  = radius.get(d.thisId) ?? 0;\n    d.angle = th;\n    d.r = r;\n    d.x = r * Math.cos(th);\n    d.y = r * Math.sin(th);\n  }\n\n  return pd;\n}\n","import radialData from \"./radialData.js\"\nimport getRadii from \"./getRadii.js\"\nimport getArcs from \"./getArcs.js\"\nimport getChildArcs from \"./getChildArcs.js\"\n\n/**\n * Simple wrapper for radial layout:\n *  - data: per-node { angle, r, x, y, ... }\n *  - radii: per-edge radial spokes (parent.r → child.r)\n *  - arcs: per-parent arcs spanning all children at parent's radius\n *  - child_arcs: per-child half-arcs (parent.angle → child.angle) at parent's radius\n */\nexport default function radialLayout(node) {\n  const data = {};\n  data.data = radialData(node);\n  data.radii = getRadii(node);\n  data.arcs = getArcs(data.data);\n  data.child_arcs = getChildArcs(data.data);\n  return data;\n}\n\n","import radialData from \"./radialData.js\";\n\n/**\n * Per-edge radial segments (for highlighting and drawing).\n * For each non-root node, draw a radial line from the parent radius to the child radius\n * at the CHILD'S angle.\n *\n * Output: [{ parentId, childId, x0, y0, x1, y1, isTip }]\n */\nexport default function getRadii(node) {\n  const data = radialData(node);\n  const byId = new Map(data.map(d => [d.thisId, d]));\n  const root = data.find(d => d.parentId == null)?.thisId;\n\n  const segments = [];\n  for (const d of data) {\n    if (d.thisId === root) continue;\n    const parent = byId.get(d.parentId);\n    if (!parent) continue;\n\n    const theta = d.angle;\n    const r0 = parent.r;\n    const r1 = d.r;\n\n    segments.push({\n      parentId: parent.thisId,\n      childId: d.thisId,\n      x0: r0 * Math.cos(theta),\n      y0: r0 * Math.sin(theta),\n      x1: r1 * Math.cos(theta),\n      y1: r1 * Math.sin(theta),\n      isTip: !!d.isTip\n    });\n  }\n  return segments;\n}\n\n","/**\n * Build arc descriptors for each internal parent:\n *  - One arc per internal node at radius = parent.r\n *  - Start/end angles choose the *shortest* wrap-aware span covering the children\n *  - Skips degenerate spans (delta ~ 0)\n */\nexport default function getArcs(pd) {\n  const TAU = Math.PI * 2;\n  const norm = (t) => ((t % TAU) + TAU) % TAU;\n  const EPS = 1e-6;\n\n  // Quick lookups\n  const byId = new Map(pd.map(d => [d.thisId, d]));\n  const childrenByParent = new Map();\n  let root = null;\n\n  for (const d of pd) {\n    if (d.parentId == null) root = d.thisId;\n    if (!childrenByParent.has(d.parentId)) childrenByParent.set(d.parentId, []);\n    childrenByParent.get(d.parentId).push(d);\n  }\n\n  const arcs = [];\n\n  for (const parent of pd) {\n    const pid = parent.thisId;\n    if (pid === root) continue; // no arc above root\n    const kids = childrenByParent.get(pid) || [];\n    if (kids.length < 2) continue; // need at least two children\n\n    // Collect & sort child angles\n    const A = kids.map(k => norm(k.angle)).sort((a, b) => a - b);\n    const aMin = A[0], aMax = A[A.length - 1];\n\n    // Two candidate spans: direct (aMin -> aMax) and wrapped (aMax -> aMin across 2π)\n    const direct = aMax - aMin;\n    const wrapped = TAU - direct;\n\n    // Choose the shorter span. We'll draw **CCW** (sweepFlag = 0) in describeArc.\n    let start, end, span;\n    if (direct <= wrapped) {\n      start = aMin;\n      end = aMax;\n      span = direct;\n    } else {\n      // wrapped is shorter: go CCW from aMax up through 2π to aMin\n      start = aMax;\n      end = aMin;\n      span = wrapped;\n    }\n\n    if (span < EPS || !isFinite(parent.r) || parent.r <= 0) continue;\n\n    arcs.push({\n      start,\n      end,\n      radius: parent.r,\n      thisId: pid,\n      parentId: parent.parentId\n    });\n  }\n\n  return arcs;\n}\n\n","/**\n * Per-child \"half\" arcs for radial trees.\n *\n * For each non-root node (child), emit an arc at the PARENT's radius that\n * spans between the parent's angle and the child's angle. This is the arc\n * segment that meets the child's spoke and is ideal for root→tip highlighting.\n *\n * Input:  pd — the array returned by radialData(node) (each row has .thisId, .parentId, .angle, .r)\n * Output: [{ parentId, childId, radius, start, end }]\n */\nexport default function getChildArcs(pd) {\n  const byId = new Map(pd.map(d => [d.thisId, d]));\n  const arcs = [];\n\n  for (const child of pd) {\n    if (child.parentId == null) continue; // skip root\n    const parent = byId.get(child.parentId);\n    if (!parent) continue;\n\n    arcs.push({\n      parentId: parent.thisId,\n      childId: child.thisId,\n      radius: parent.r,        // draw on the parent's circle\n      start: parent.angle,     // start at parent's angle\n      end: child.angle         // end at child's angle (describeArc will choose the shortest CCW span)\n    });\n  }\n\n  return arcs;\n}\n\n","import mean from \"../utils/mean.js\"\nimport fortify from \"../utils/fortify.js\"\n\n/**\n * Rectangle layout: compute per-node x0,x1 and y0=y1\n * - Tip y is assigned by input order (preserves ladderize/order)\n * - Internal node y is mean of child y's\n * - x1 accumulates branch lengths from root\n */\n\nexport default function getHorizontal(node) {\n  const pd = fortify(node);\n\n  // Fast lookup from id -> pd index\n  const idIndex = new Map(pd.map((d, i) => [d.thisId, i]));\n\n  // 1) Leaf order from the INPUT TREE (respects your child order / ladderize)\n  const leafIds = [];\n  (function dfs(n) {\n    if (!n.children || n.children.length === 0) { leafIds.push(n.id); return; }\n    n.children.forEach(dfs);\n  })(node);\n\n  // Map each leaf id to a vertical slot (1..N)\n  const tipSlot = new Map(leafIds.map((id, i) => [id, i + 1]));\n\n  // 2) Set Y for tips directly from that order; internal node Y via children mean\n  (function setY(n) {\n    const i = idIndex.get(n.id);\n    if (!n.children || n.children.length === 0) {\n      const y = tipSlot.get(n.id);\n      pd[i].y0 = y; pd[i].y1 = y;\n      return y;\n    }\n    const ys = n.children.map(setY);\n    const y = mean(ys);\n    pd[i].y0 = y; pd[i].y1 = y;\n    return y;\n  })(node);\n\n  // 3) Set X by accumulating branch lengths down the tree\n  (function setX(n, xParent) {\n    const i = idIndex.get(n.id);\n    const bl = pd[i].branchLength ?? 0;\n    const x0 = xParent ?? 0;\n    const x1 = x0 + bl;\n    pd[i].x0 = x0; pd[i].x1 = x1;\n    if (n.children && n.children.length) n.children.forEach(c => setX(c, x1));\n  })(node, 0);\n\n  // Clean up: remove fields not needed downstream without triggering no-unused-vars\n  return pd.map((row) => {\n    const { y: _y, x: _x, angle: _angle, ...item } = row;\n    return item;\n  });\n}\n\n","/**\n * Iterable mean\n * Poached from https://github.com/d3/d3-array/blob/master/src/mean.js\n * (Other array means buggered up the tree)\n */\n\nexport default function (values, valueof) {\n    let count = 0;\n    let sum = 0;\n    if (valueof === undefined) {\n        for (let value of values) {\n            if (value != null && (value = +value) >= value) {\n                ++count, sum += value;\n            }\n        }\n    } else {\n        let index = -1;\n        for (let value of values) {\n            if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n                ++count, sum += value;\n            }\n        }\n    }\n    if (count) return sum / count;\n}\n","import getHorizontal from \"./getHorizontal.js\"\nimport getVertical from \"./getVertical.js\"\nimport getChildVerticals from \"./getChildVerticals.js\"\n\n/**\n * Rectangle layout wrapper.\n * Returns:\n *  - data: per-node rows (x0,x1,y0=y1,...)\n *  - vertical_lines: single spanning vertical per parent (baseline draw)\n *  - child_vertical_lines: one vertical per edge (for highlighting)\n *  - horizontal_lines: per-edge child horizontals (x0->x1 at y), with labels & tip flags\n */\nexport default function rectangleLayout(node) {\n  const data = getHorizontal(node);              // per-node\n  const vertical_lines = getVertical(node);      // parent spans\n  const child_vertical_lines = getChildVerticals(node); // per-edge verticals\n\n  // IMPORTANT: include y0 & y1, and carry isTip/labels for the renderer\n  const byId = new Map(data.map(d => [d.thisId, d]));\n  const horizontal_lines = data\n    .filter(d => d.parentId != null)\n    .map(d => ({\n      parentId: d.parentId,\n      childId: d.thisId,\n      thisId: d.thisId,\n      thisLabel: d.thisLabel,\n      isTip: d.isTip,\n      x0: d.x0,\n      x1: d.x1,\n      y0: d.y0,\n      y1: d.y0\n    }));\n\n  return { data, vertical_lines, child_vertical_lines, horizontal_lines };\n}\n\n","import getHorizontal from \"./getHorizontal.js\"\n\nexport default function getVertical(node) {\n  const data = getHorizontal(node);\n\n  // Group rows by parentId (children that share a parent)\n  const byParent = new Map();\n  for (const row of data) {\n    if (row.parentId == null) continue;\n    const a = byParent.get(row.parentId);\n    if (a) a.push(row); else byParent.set(row.parentId, [row]);\n  }\n\n  const verticals = [];\n  for (const [parentId, kids] of byParent.entries()) {\n    if (!kids.length) continue;\n    // Works for binary and multifurcations:\n    const yvals = kids.map(d => d.y0);\n    const y0 = Math.min(...yvals);\n    const y1 = Math.max(...yvals);\n    // All children share the same junction x (their x0)\n    const x = kids[0].x0;\n\n    verticals.push({\n      parentId,\n      x0: x,\n      x1: x,\n      y0,\n      y1,\n      heights: y1 - y0\n    });\n  }\n\n  return verticals;\n}\n\n","import getHorizontal from \"./getHorizontal.js\";\n\n/**\n * Build per-child vertical segments for a rectangular tree:\n * For each non-root node (child), draw a vertical from (parent.x, child.y) to (parent.x, parent.y).\n * This yields exactly one vertical per edge (child->parent), making highlighting trivial.\n *\n * Returns an array of:\n *   {\n *     parentId: number,\n *     childId: number,\n *     x: number,         // x of the parent junction\n *     y0: number,        // min(child.y, parent.y)\n *     y1: number,        // max(child.y, parent.y)\n *   }\n */\nexport default function getChildVerticals(node) {\n  const data = getHorizontal(node); // has parentId, thisId, x0,x1,y0=y1\n\n  // Build a quick index to access parent's y by id\n  const byId = new Map(data.map(d => [d.thisId, d]));\n\n  const childVerticals = [];\n\n  for (const d of data) {\n    if (d.parentId == null) continue;\n    const parent = byId.get(d.parentId);\n    if (!parent) continue;\n\n    const x = d.x0;            // child’s vertical sits at parent.x == child.x0\n    const yc = d.y0;           // child y\n    const yp = parent.y0;      // parent y\n    const y0 = Math.min(yc, yp);\n    const y1 = Math.max(yc, yp);\n\n    childVerticals.push({\n      parentId: d.parentId,\n      childId: d.thisId,\n      x,\n      y0,\n      y1\n    });\n  }\n\n  return childVerticals;\n}\n\n","import numTips from \"../utils/numTips.js\"\n\n/**\n * Equal-angle layout for unrooted trees.\n * - Precomputes ntips in O(n) to avoid repeated subtree counts\n * - Uses angles in \"π units\" (0..2) to match existing API\n * - Populates x,y positions from branchLength and angle\n */\n\nfunction annotateTipCounts(root) {\n  (function post(n) {\n    if (!n.children || n.children.length === 0) {\n      n.ntips = 1; return 1;\n    }\n    let sum = 0;\n    for (const c of n.children) sum += post(c);\n    n.ntips = sum;\n    return sum;\n  })(root);\n  return root;\n}\n\nfunction equalAngleLayout(node) {\n  if (node.parent === null) {\n    annotateTipCounts(node);\n    node.start = 0.;     // guarantees no arcs overlap 0\n    node.end = 2.;       // *π\n    node.angle = 0.;     // irrelevant at root\n    node.ntips = numTips(node); // safe (already computed), left for compatibility\n    node.x = 0;\n    node.y = 0;\n  }\n\n  let lastStart = node.start;\n\n  for (let i = 0; i < node.children.length; i++) {\n    const child = node.children[i];\n    const arc = (node.end - node.start) * (child.ntips / node.ntips);\n\n    child.start = lastStart;\n    child.end = lastStart + arc;\n\n    // bisect the arc in π-units\n    child.angle = child.start + (child.end - child.start) / 2.;\n    lastStart = child.end;\n\n    // map to coordinates (convert π-units to radians by multiplying by Math.PI)\n    const theta = child.angle * Math.PI;\n    const bl = (child.branchLength ?? 0);\n    child.x = node.x + bl * Math.sin(theta);\n    child.y = node.y + bl * Math.cos(theta);\n\n    equalAngleLayout(child);\n  }\n\n  return node;\n}\n\nexport default equalAngleLayout\n\n","/**\n * Recursive function for breadth-first search of a tree\n * the root node is visited first.\n */\n\nfunction levelorder(root) {\n  const queue = [root], result = [];\n  while (queue.length) {\n    const curnode = queue.shift();         // <- FIFO\n    result.push(curnode);\n    for (const child of curnode.children) queue.push(child);\n  }\n  return result;\n}\n\n\n/**\n * Count the number of tips that descend from this node\n */\n\nexport default function(thisnode) {\n  var result = 0;\n  for (const node of levelorder(thisnode)) {\n    if (node.children.length == 0) result++;\n  }\n  return (result);\n}\n","import edges from \"../utils/edges.js\";\nimport fortify from \"../utils/fortify.js\";\nimport equalAngleLayout from \"./equalAngleLayout.js\";\n\n/**\n * Simple wrapper function for equalAngleLayout()\n */\n\nexport default function (node) {\n  var data = {};\n  // use the Felsenstein equal angle layout algorithm\n  var eq = fortify(equalAngleLayout(node));\n  data.data = eq;\n  // make the edges dataset\n  data.edges = edges(eq);\n\n  return data;\n}\n","/**\n * Convert parsed Newick tree from fortify() into data frame of edges\n * this is akin to a \"phylo\" object in R, where thisID and parentId\n * are the $edge slot. I think.\n */\n\nexport default function edges(df, rectangular = false) {\n  const rows = [...df].sort((a, b) => a.thisId - b.thisId);\n  const byId = new Map(rows.map((r) => [r.thisId, r]));\n  const result = [];\n\n  for (const row of rows) {\n    if (row.parentId == null) continue;\n    const parent = byId.get(row.parentId);\n    if (!parent) continue;\n\n    if (rectangular) {\n      result.push({ x1: row.x, y1: row.y, id1: row.thisId, x2: parent.x, y2: row.y, id2: undefined });\n      result.push({ x1: parent.x, y1: row.y, id1: undefined, x2: parent.x, y2: parent.y, id2: row.parentId });\n    } else {\n      result.push({ x1: row.x, y1: row.y, id1: row.thisId, x2: parent.x, y2: parent.y, id2: row.parentId });\n    }\n  }\n  return result;\n}\n\n","/**\n * Parse a Newick tree string into a doubly-linked list of JS Objects.\n * Assigns labels, branch lengths, and node IDs (tips before internals if input emits them that way).\n *\n * Notes / limitations:\n * - Quoted labels and NHX annotations are not fully supported.\n * - Branch lengths in scientific notation are supported (parseFloat).\n */\n\nexport default function readTree(text) {\n  // Remove all whitespace (space, tabs, newlines)\n  text = String(text).replace(/\\s+/g, '');\n\n  const tokens = text.split(/(;|\\(|\\)|,)/);\n  const root = { parent: null, children: [] };\n  let curnode = root;\n  let nodeId = 0;\n\n  for (const token of tokens) {\n    if (!token || token === ';') continue;\n\n    if (token === '(') {\n      const child = { parent: curnode, children: [] };\n      curnode.children.push(child);\n      curnode = child; // descend\n    } else if (token === ',') {\n      // back to parent, then create sibling\n      curnode = curnode.parent;\n      const child = { parent: curnode, children: [] };\n      curnode.children.push(child);\n      curnode = child;\n    } else if (token === ')') {\n      // ascend one level\n      curnode = curnode.parent;\n      if (curnode === null) break;\n    } else {\n      // label/branch-length chunk (e.g., \"A:0.01\" or \"A\")\n      const nodeinfo = token.split(':');\n      if (nodeinfo.length === 1) {\n        if (token.startsWith(':')) {\n          curnode.label = '';\n          curnode.branchLength = parseFloat(nodeinfo[0]);\n        } else {\n          curnode.label = nodeinfo[0];\n          curnode.branchLength = null;\n        }\n      } else if (nodeinfo.length === 2) {\n        curnode.label = nodeinfo[0];\n        curnode.branchLength = parseFloat(nodeinfo[1]);\n      } else {\n        console.warn(token, \"Unhandled token with multiple ':' characters\");\n        curnode.label = nodeinfo[0] || '';\n        curnode.branchLength = parseFloat(nodeinfo[nodeinfo.length - 1]);\n      }\n      curnode.id = nodeId++; // assign then increment\n    }\n  }\n\n  // Ensure root has an id if not assigned during parsing\n  if (root.id == null) root.id = nodeId;\n\n  return root;\n}\n\n","import * as d3 from \"d3\";\nimport * as lw from \"../index.js\";\n\nexport default function drawPhylogeny(\n  treeText,\n  {\n    layout = \"rect\", // \"rect\" or \"radial\"\n    width = 800,\n    height = 800,\n    margin = { top: 20, right: 300, bottom: 20, left: 50 },\n    radialMargin = 80,\n    strokeWidth = 1,\n    radialMode = \"outer\" // or \"align\"\n  } = {}\n) {\n  if (layout === \"rect\") {\n    // RECTANGULAR LAYOUT\n    const tree_df = lw.rectangleLayout(lw.readTree(treeText));\n    const horizontal = tree_df.horizontal_lines;\n    const vertical = tree_df.vertical_lines;\n    const tips = horizontal.filter((d) => d.isTip);\n\n    const maxY = d3.max(horizontal, (d) => d.y1);\n    const minY = d3.min(horizontal, (d) => d.y1);\n    const maxX = d3.max(horizontal, (d) => d.x1);\n\n    const yScale = d3\n      .scaleLinear()\n      .domain([minY - 1, maxY + 1])\n      .range([margin.top, height - margin.bottom]);\n\n    const xScale = d3\n      .scaleLinear()\n      .domain([0, maxX])\n      .range([margin.left, width - margin.right]);\n\n    const svg = d3\n      .create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"font-family\", \"sans-serif\")\n      .attr(\"font-size\", 10);\n\n    const group = svg.append(\"g\");\n\n    group\n      .selectAll(\".hline\")\n      .data(horizontal)\n      .join(\"line\")\n      .attr(\"x1\", (d) => xScale(d.x0))\n      .attr(\"y1\", (d) => yScale(d.y0))\n      .attr(\"x2\", (d) => xScale(d.x1))\n      .attr(\"y2\", (d) => yScale(d.y1))\n      .attr(\"stroke\", \"#555\")\n      .attr(\"stroke-width\", strokeWidth);\n\n    group\n      .selectAll(\".vline\")\n      .data(vertical)\n      .join(\"line\")\n      .attr(\"x1\", (d) => xScale(d.x0))\n      .attr(\"y1\", (d) => yScale(d.y0))\n      .attr(\"x2\", (d) => xScale(d.x1))\n      .attr(\"y2\", (d) => yScale(d.y1))\n      .attr(\"stroke\", \"#555\")\n      .attr(\"stroke-width\", strokeWidth);\n\n    group\n      .selectAll(\".tip-dot\")\n      .data(tips)\n      .join(\"circle\")\n      .attr(\"cx\", (d) => xScale(d.x1))\n      .attr(\"cy\", (d) => yScale(d.y1))\n      .attr(\"r\", 2)\n      .attr(\"fill\", \"black\");\n\n    svg\n      .append(\"g\")\n      .selectAll(\"text\")\n      .data(tips)\n      .join(\"text\")\n      .attr(\"x\", (d) => xScale(d.x1) + 4)\n      .attr(\"y\", (d) => yScale(d.y1))\n      .attr(\"dy\", \"0.32em\")\n      .attr(\"font-size\", 10)\n      .text((d) => d.thisLabel?.replace(/_/g, \" \") ?? \"\");\n\n    return svg.node();\n  } else if (layout === \"radial\") {\n    // RADIAL LAYOUT\n    if (width !== height) {\n      new Error(\"width and height must be the same for radial layout\");\n    }\n    const parsedTree = lw.readTree(treeText);\n    const rad = lw.radialLayout(parsedTree);\n\n    // ===== MODE =====\n    const TIP_MODE = radialMode; // \"align\" (shorten to original tips) or \"outer\" (project to one circle)\n    const isOuter = TIP_MODE === \"outer\";\n    if (TIP_MODE != \"phylo\" || TIP_MODE != \"outer\") {\n      new Error(\"radialMode can be only either 'outer' to align tips around the circumference, or 'phylo' which shows terminal branch lengths\");\n    }\n\n    // visuals (0 = let spokes reach the dots)\n    const DOT_R = 3;\n    const END_CAP = 0;\n\n    // ===== SCALES / BOUNDS =====\n    const maxRadius = d3.max(rad.data, (d) => d.r) ?? 0;\n    const scaleRadial = maxRadius + 2 * radialMargin;\n    const w = width,\n      h = height;\n    const centerX = w / 2,\n      centerY = h / 2;\n\n    const xScaleRadial = d3\n      .scaleLinear()\n      .domain([-scaleRadial, scaleRadial])\n      .range([0, w]);\n    const yScaleRadial = d3\n      .scaleLinear()\n      .domain([-scaleRadial, scaleRadial])\n      .range([h, 0]);\n    const radiusPx = (r) => r * (w / (2 * scaleRadial));\n\n    // ===== INDEXES / HELPERS =====\n    const byId = new Map(rad.data.map((d) => [d.thisId, d]));\n    const tips = rad.data.filter((d) => d.isTip);\n    const tipMaxR = tips.length ? d3.max(tips, (d) => d.r) : 0;\n\n    // Robust child-id extractor (handles multiple shapes)\n    function childIdOf(spoke) {\n      // prefer explicit child id fields; fall back to thisId; last-ditch id1 (seen in some edge shapes)\n      return spoke.childId ?? spoke.thisId ?? spoke.id1 ?? null;\n    }\n\n    // Shorten the *screen-space* end of a spoke by END_CAP px\n    function shortenSpokePx(x0, y0, x1, y1) {\n      const X0 = xScaleRadial(x0),\n        Y0 = yScaleRadial(y0);\n      const X1 = xScaleRadial(x1),\n        Y1 = yScaleRadial(y1);\n      const dx = X1 - X0,\n        dy = Y1 - Y0;\n      const len = Math.hypot(dx, dy) || 1;\n      const t = Math.max(0, (len - END_CAP) / len);\n      return { X0, Y0, X1s: X0 + dx * t, Y1s: Y0 + dy * t, len };\n    }\n\n    // ===== SVG ROOT =====\n    const svg = d3\n      .create(\"svg\")\n      .attr(\"width\", w)\n      .attr(\"height\", h)\n      .attr(\"font-family\", \"sans-serif\")\n      .attr(\"font-size\", 10);\n\n    const group = svg.append(\"g\");\n\n    // ===== ARCS (parent circles) =====\n    group\n      .append(\"g\")\n      .attr(\"class\", \"phylo_arcs\")\n      .selectAll(\"path\")\n      .data(rad.arcs)\n      .join(\"path\")\n      .attr(\"d\", (d) =>\n        lw.describeArc(\n          centerX,\n          centerY,\n          Math.max(0, radiusPx(d.radius)),\n          d.start,\n          d.end\n        )\n      )\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", \"#777\")\n      .attr(\"stroke-width\", strokeWidth);\n\n    // ===== RADII (spokes) =====\n    group\n      .append(\"g\")\n      .attr(\"class\", \"phylo_radii\")\n      .selectAll(\"line\")\n      .data(rad.radii)\n      .join(\"line\")\n      .each(function(s, _) {\n        // parent end (data space)\n        const x0 = s.x0,\n          y0 = s.y0;\n\n        // child end (data space), shape-agnostic\n        const cid = childIdOf(s);\n        const node = cid != null ? byId.get(cid) : undefined;\n        const isTipSpoke = !!(node && node.isTip);\n\n        // default to the original child endpoint from the spoke record\n        let x1 = s.x1,\n          y1 = s.y1;\n\n        // In \"outer\" mode, project only *tip* spokes to the common circle\n        if (isOuter && isTipSpoke) {\n          x1 = tipMaxR * Math.cos(node.angle);\n          y1 = tipMaxR * Math.sin(node.angle);\n        }\n\n        // Shorten in screen space so the spoke doesn’t pierce the dot (END_CAP can be 0)\n        const { X0, Y0, X1s, Y1s, _len } = shortenSpokePx(x0, y0, x1, y1);\n\n        d3.select(this)\n          .attr(\"x1\", X0)\n          .attr(\"y1\", Y0)\n          .attr(\"x2\", X1s)\n          .attr(\"y2\", Y1s)\n          .attr(\"stroke\", \"#777\")\n          .attr(\"stroke-width\", strokeWidth);\n      });\n\n    // ===== TIP DOTS =====\n    group\n      .append(\"g\")\n      .attr(\"class\", \"phylo_tip_dots\")\n      .selectAll(\"circle\")\n      .data(tips)\n      .join(\"circle\")\n      .each(function(d, _) {\n        // dot at original tip (align) or projected circle (outer)\n        const x = isOuter ? tipMaxR * Math.cos(d.angle) : d.x;\n        const y = isOuter ? tipMaxR * Math.sin(d.angle) : d.y;\n\n        d3.select(this)\n          .attr(\"cx\", xScaleRadial(x))\n          .attr(\"cy\", yScaleRadial(y))\n          .attr(\"r\", DOT_R)\n          .attr(\"fill\", \"black\")\n          .attr(\"stroke\", \"black\")\n          .attr(\"stroke-width\", 1.5);\n      });\n\n    // ===== LABELS (unchanged) =====\n    // Labels — make them follow the tip position used by the current mode\n    group\n      .append(\"g\")\n      .attr(\"class\", \"phylo_labels\")\n      .selectAll(\"g.label\")\n      .data(tips) // <— bind only tip nodes\n      .join(\"g\")\n      .attr(\"class\", \"label\")\n      .attr(\"transform\", (d) => {\n        // same tip position rule as dots/spokes:\n        //  - \"outer\": snap to common ring (tipMaxR)\n        //  - otherwise (e.g. \"align\"/\"phylo\"): true tip radius\n        const r = isOuter ? tipMaxR : d.r;\n        const x = r * Math.cos(d.angle);\n        const y = r * Math.sin(d.angle);\n        return `translate(${xScaleRadial(x)},${yScaleRadial(y)})`;\n      })\n      .each(function(d) {\n        // rotate so text reads outward; flip when on the left side\n        let angle = (-d.angle * 180) / Math.PI;\n        let xoff = 10; // radial padding for text (px)\n        let anchor = \"start\";\n        if (d.angle > Math.PI / 2 && d.angle < (3 * Math.PI) / 2) {\n          angle += 180;\n          xoff *= -1;\n          anchor = \"end\";\n        }\n        d3.select(this)\n          .append(\"g\")\n          .attr(\"transform\", `rotate(${angle})`)\n          .append(\"text\")\n          .attr(\"x\", xoff)\n          .attr(\"alignment-baseline\", \"middle\")\n          .attr(\"text-anchor\", anchor)\n          .attr(\"font-size\", 10)\n          .attr(\"fill\", \"black\")\n          .text((d) => d.thisLabel?.replace(/_/g, \" \") ?? \"\");\n      });\n\n    return svg.node();\n  } else if (layout === \"unrooted\") {\n    // UNROOTED LAYOUT\n    const parsedTree = lw.readTree(treeText);\n    const unrootedPhylo = lw.unrooted(parsedTree);\n\n    const w = width;\n    const h = height;\n\n    // Get spatial extent\n    const xExtent = d3.extent(unrootedPhylo.data, (d) => d.x);\n    const yExtent = d3.extent(unrootedPhylo.data, (d) => d.y);\n\n    // Find maximum absolute distance from center (0,0)\n    const maxX = Math.max(Math.abs(xExtent[0]), Math.abs(xExtent[1]));\n    const maxY = Math.max(Math.abs(yExtent[0]), Math.abs(yExtent[1]));\n    const maxRadius = Math.max(maxX, maxY);\n\n    // Add some margin\n    const scaleUnroot = maxRadius + 2 * radialMargin;\n\n    const xScaleUnroot = d3\n      .scaleLinear()\n      .domain([-scaleUnroot, scaleUnroot])\n      .range([0, w]);\n\n    const yScaleUnroot = d3\n      .scaleLinear()\n      .domain([-scaleUnroot, scaleUnroot])\n      .range([h, 0]);\n\n    const svg = d3\n      .create(\"svg\")\n      .attr(\"width\", w)\n      .attr(\"height\", h)\n      .attr(\"font-family\", \"sans-serif\")\n      .attr(\"font-size\", 10);\n\n    const group = svg.append(\"g\");\n\n    // Edges\n    group\n      .append(\"g\")\n      .attr(\"class\", \"phylo_lines\")\n      .selectAll(\"line\")\n      .data(unrootedPhylo.edges)\n      .join(\"line\")\n      .attr(\"x1\", (d) => xScaleUnroot(d.x1))\n      .attr(\"y1\", (d) => yScaleUnroot(d.y1))\n      .attr(\"x2\", (d) => xScaleUnroot(d.x2))\n      .attr(\"y2\", (d) => yScaleUnroot(d.y2))\n      .attr(\"stroke-width\", strokeWidth)\n      .attr(\"stroke\", \"#777\");\n\n    // Nodes\n    group\n      .append(\"g\")\n      .attr(\"class\", \"phylo_points\")\n      .selectAll(\"circle\")\n      .data(unrootedPhylo.data)\n      .join(\"circle\")\n      .attr(\"class\", \"dot\")\n      .attr(\"r\", (d) => (d.isTip ? 4 : 0))\n      .attr(\"cx\", (d) => xScaleUnroot(d.x))\n      .attr(\"cy\", (d) => yScaleUnroot(d.y))\n      .attr(\"stroke\", \"black\")\n      .attr(\"stroke-width\", 2)\n      .attr(\"fill\", (d) => (d.isTip ? \"black\" : \"white\"));\n\n    // Tip labels\n    const tipEdges = new Map();\n    const nodesById = new Map(unrootedPhylo.data.map((d) => [d.thisId, d]));\n\n    unrootedPhylo.edges.forEach((edge) => {\n      const tipNode = nodesById.get(edge.id1);\n      if (tipNode?.isTip) {\n        tipEdges.set(edge.id1, edge);\n      }\n    });\n\n    group\n      .append(\"g\")\n      .attr(\"class\", \"phylo_labels\")\n      .selectAll(\"g\")\n      .data(unrootedPhylo.data.filter((d) => d.isTip))\n      .join(\"g\")\n      .attr(\"transform\", (d) => {\n        const x = xScaleUnroot(d.x);\n        const y = yScaleUnroot(d.y);\n        return `translate(${x},${y})`;\n      })\n      .each(function(d) {\n        const edge = tipEdges.get(d.thisId);\n        if (!edge) {\n          console.warn(\n            \"No incoming edge found for tip node:\",\n            d.thisId,\n            d.thisLabel\n          );\n          return;\n        }\n\n        // Compute angle of the incoming edge (screen coords)\n        const x1 = xScaleUnroot(edge.x1);\n        const y1 = yScaleUnroot(edge.y1);\n        const x2 = xScaleUnroot(edge.x2);\n        const y2 = yScaleUnroot(edge.y2);\n\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        let angle = (Math.atan2(dy, dx) * 180) / Math.PI;\n\n        // Flip label if upside down\n        let xOffset = -10;\n        let anchor = \"end\";\n        if (angle > 90 || angle < -90) {\n          angle += 180;\n          anchor = \"start\";\n          xOffset = 10;\n        }\n\n        // Draw label rotated along branch direction\n        d3.select(this)\n          .append(\"g\")\n          .attr(\"transform\", `rotate(${angle})`)\n          .append(\"text\")\n          .attr(\"x\", xOffset)\n          .attr(\"alignment-baseline\", \"middle\")\n          .attr(\"text-anchor\", anchor)\n          .attr(\"font-size\", 10)\n          .attr(\"fill\", \"black\")\n          .text(d.thisLabel?.replace(/_/g, \" \") ?? \"\");\n      });\n\n    return svg.node();\n  } else {\n    throw new Error(\"Unsupported layout type. Use 'rect' or 'radial'.\");\n  }\n}\n","import polarToCartesian from \"./polarToCartesian.js\";\n\n/**\n * Draw the shortest arc between startAngle and endAngle (radians), CCW.\n * If the CW path is shorter, swap start/end so the CCW path is still shortest.\n * Works with Y-inverted screen coords (polarToCartesian already inverts Y).\n */\nexport default function describeArc(cx, cy, radius, startAngle, endAngle) {\n  const TAU = Math.PI * 2;\n  const norm = (t) => ((t % TAU) + TAU) % TAU;\n  let a0 = norm(startAngle);\n  let a1 = norm(endAngle);\n\n  // CCW and CW spans\n  const ccw = (a1 - a0 + TAU) % TAU;\n  const cw = (a0 - a1 + TAU) % TAU;\n\n  // Ensure we always take the shorter span *in CCW* by swapping if needed\n  if (cw < ccw) {\n    const tmp = a0; a0 = a1; a1 = tmp;\n  }\n\n  const delta = (a1 - a0 + TAU) % TAU;          // now the shorter CCW span\n  if (delta < 1e-9) {\n    const p = polarToCartesian(cx, cy, radius, a0);\n    return `M ${p.x} ${p.y}`;                   // degenerate span → no arc\n  }\n\n  const largeArcFlag = delta > Math.PI ? 1 : 0; // should be 0 for “shortest”, but keep for safety\n  const sweepFlag = 0;                          // CCW\n\n  const p0 = polarToCartesian(cx, cy, radius, a0);\n  const p1 = polarToCartesian(cx, cy, radius, a1);\n\n  return `M ${p0.x} ${p0.y} A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${p1.x} ${p1.y}`;\n}\n\n"],"names":["polarToCartesian","cx","cy","r","t","x","Math","cos","y","sin","preorder","node","list","push","i","children","length","fortify","tree","sort","df","parent","parentId","parentLabel","thisId","id","thisLabel","label","map","branchLength","isTip","angle","a","b","radialData","TAU","PI","pd","byId","Map","d","kids","root","tipIds","dfs","c","get","ch","N","max","forEach","set","setInternalAngles","sx","sy","th","atan2","radius","setR","r0","child","bl","radialLayout","data","radii","find","segments","theta","r1","childId","x0","y0","x1","y1","getRadii","arcs","childrenByParent","has","pid","A","k","aMin","aMax","direct","wrapped","start","end","span","isFinite","getArcs","child_arcs","getChildArcs","getHorizontal","idIndex","leafIds","n","tipSlot","setY","values","count","sum","value","mean","setX","xParent","row","_y","_x","_angle","item","rectangleLayout","vertical_lines","byParent","verticals","entries","yvals","min","heights","getVertical","child_vertical_lines","childVerticals","yc","yp","getChildVerticals","horizontal_lines","filter","equalAngleLayout","post","ntips","thisnode","result","queue","curnode","shift","levelorder","numTips","lastStart","arc","unrooted","eq","edges","rectangular","rows","id1","x2","y2","id2","undefined","readTree","text","tokens","String","replace","split","nodeId","token","nodeinfo","startsWith","parseFloat","console","warn","treeText","layout","width","height","margin","top","right","bottom","left","radialMargin","strokeWidth","radialMode","tree_df","lw.rectangleLayout","lw.readTree","horizontal","vertical","tips","maxY","d3","minY","maxX","yScale","scaleLinear","domain","range","xScale","svg","create","attr","group","append","selectAll","join","rad","lw.radialLayout","isOuter","DOT_R","END_CAP","scaleRadial","w","h","centerX","centerY","xScaleRadial","yScaleRadial","radiusPx","tipMaxR","shortenSpokePx","X0","Y0","dx","dy","len","hypot","X1s","Y1s","startAngle","endAngle","norm","a0","a1","tmp","delta","p","largeArcFlag","p0","p1","lw.describeArc","each","s","_","cid","spoke","isTipSpoke","select","this","xoff","anchor","unrootedPhylo","lw.unrooted","xExtent","extent","yExtent","abs","scaleUnroot","xScaleUnroot","yScaleUnroot","tipEdges","nodesById","edge","tipNode","xOffset","Error"],"mappings":"ghBACe,SAAAA,EAAUC,EAAIC,EAAIC,EAAGC,GAClC,MAAO,CAAEC,EAAGJ,EAAKE,EAAIG,KAAKC,IAAIH,GAAII,EAAGN,EAAKC,EAAIG,KAAKG,IAAIL,GACzD,CCAO,SAASM,EAASC,EAAMC,EAAO,IACpCA,EAAKC,KAAKF,GACV,IAAK,IAAIG,EAAI,EAAGA,GAAKH,EAAKI,UAAUC,QAAU,GAAIF,IAChDF,EAAOF,EAASC,EAAKI,SAASD,GAAIF,GAEpC,OAAOA,CACT,CCDe,SAAAK,EAAUC,EAAMC,GAAO,GAClC,IAAIC,EAAK,GAET,IAAK,MAAMT,KAAQD,EAASQ,GACJ,OAAhBP,EAAKU,OACLD,EAAGP,KAAK,CACJS,SAAY,KACZC,YAAe,KACfC,OAAUb,EAAKc,GACfC,UAAaf,EAAKgB,MAClBZ,SAAYJ,EAAKI,SAASa,IAAIvB,GAAKA,EAAEoB,IACrCI,aAAgB,EAChBC,OAAS,EACTzB,EAAKM,EAAKN,EACVG,EAAKG,EAAKH,EACVuB,MAASpB,EAAKoB,QAIlBX,EAAGP,KAAK,CACJS,SAAYX,EAAKU,OAAOI,GACxBF,YAAeZ,EAAKU,OAAOM,MAC3BH,OAAUb,EAAKc,GACfC,UAAaf,EAAKgB,MAClBZ,SAAYJ,EAAKI,SAASa,IAAIvB,GAAKA,EAAEoB,IACrCI,aAAgBlB,EAAKkB,aACrBC,MAAkC,GAAxBnB,EAAKI,SAASC,OACxBX,EAAKM,EAAKN,EACVG,EAAKG,EAAKH,EACVuB,MAASpB,EAAKoB,QAU1B,OALIZ,IACAC,EAAKA,EAAGD,KAAK,SAAUa,EAAGC,GACtB,OAAOD,EAAER,OAASS,EAAET,MACxB,KAGR,CCrCe,SAASU,EAAWvB,GACjC,MAAMwB,EAAgB,EAAV7B,KAAK8B,GAGXC,EAAKpB,EAAQN,GAAe,GAC5B2B,EAAO,IAAIC,IAAIF,EAAGT,IAAIY,GAAK,CAACA,EAAEhB,OAAQgB,KACtCC,EAAO,IAAIF,IAAIF,EAAGT,IAAIY,GAAK,CAACA,EAAEhB,OAAQgB,EAAEzB,UAAY,MAG1D,IAAI2B,EAAO,KACX,IAAK,MAAMF,KAAKH,EACd,GAAkB,MAAdG,EAAElB,SAAkB,CAAEoB,EAAOF,EAAEhB,OAAQ,KAAO,CAIpD,MAAMmB,EAAS,IACf,SAAUC,EAAInB,GACZ,MAAMoB,EAAIJ,EAAKK,IAAIrB,IAAO,GAC1B,GAAiB,IAAboB,EAAE7B,OAIN,IAAK,MAAM+B,KAAMF,EAAGD,EAAIG,QAHtBJ,EAAO9B,KAAKY,EAIf,CAPD,CAOGiB,GAGH,MAAMM,EAAI1C,KAAK2C,IAAI,EAAGN,EAAO3B,QACvBe,EAAQ,IAAIQ,IAClBI,EAAOO,QAAQ,CAACzB,EAAIX,KAClBiB,EAAMoB,IAAI1B,EAAKX,EAAIkC,EAAKb,KAI1B,SAAUiB,EAAkB3B,GAC1B,MAAMoB,EAAIJ,EAAKK,IAAIrB,IAAO,GAC1B,IAAK,MAAMsB,KAAMF,EAAGO,EAAkBL,GACtC,GAAIF,EAAE7B,OAAS,EAAG,CAChB,IAAIqC,EAAK,EAAGC,EAAK,EACjB,IAAK,MAAMP,KAAMF,EAAG,CAClB,MAAMU,EAAKxB,EAAMe,IAAIC,GACrBM,GAAM/C,KAAKC,IAAIgD,GACfD,GAAMhD,KAAKG,IAAI8C,EACjB,CACAxB,EAAMoB,IAAI1B,GAASnB,KAAKkD,MAAMF,EAAID,GAzCZlB,EAAOA,GAAOA,EA0CtC,CACD,CAZD,CAYGO,GAGH,MAAMe,EAAS,IAAIlB,IACnBkB,EAAON,IAAIT,EAAM,GACjB,SAAUgB,EAAKjC,GACb,MAAMoB,EAAIJ,EAAKK,IAAIrB,IAAO,GACpBkC,EAAKF,EAAOX,IAAIrB,IAAO,EAC7B,IAAK,MAAMsB,KAAMF,EAAG,CAClB,MAAMe,EAAQtB,EAAKQ,IAAIC,GACjBc,EAAKD,GAAO/B,cAAgB,EAClC4B,EAAON,IAAIJ,EAAIY,EAAKE,GACpBH,EAAKX,EACP,CACD,CATD,CASGL,GAGH,IAAK,MAAMF,KAAKH,EAAI,CAClB,MAAMkB,EAAKxB,EAAMe,IAAIN,EAAEhB,SAAW,EAC5BrB,EAAKsD,EAAOX,IAAIN,EAAEhB,SAAW,EACnCgB,EAAET,MAAQwB,EACVf,EAAErC,EAAIA,EACNqC,EAAEnC,EAAIF,EAAIG,KAAKC,IAAIgD,GACnBf,EAAEhC,EAAIL,EAAIG,KAAKG,IAAI8C,EACrB,CAEA,OAAOlB,CACT,CCvEe,SAASyB,EAAanD,GACnC,MAAMoD,EAAO,CAAA,EAKb,OAJAA,EAAKA,KAAO7B,EAAWvB,GACvBoD,EAAKC,MCNQ,SAAkBrD,GAC/B,MAAMoD,EAAO7B,EAAWvB,GAClB2B,EAAO,IAAIC,IAAIwB,EAAKnC,IAAIY,GAAK,CAACA,EAAEhB,OAAQgB,KACxCE,EAAOqB,EAAKE,KAAKzB,GAAmB,MAAdA,EAAElB,WAAmBE,OAE3C0C,EAAW,GACjB,IAAK,MAAM1B,KAAKuB,EAAM,CACpB,GAAIvB,EAAEhB,SAAWkB,EAAM,SACvB,MAAMrB,EAASiB,EAAKQ,IAAIN,EAAElB,UAC1B,IAAKD,EAAQ,SAEb,MAAM8C,EAAQ3B,EAAET,MACV4B,EAAKtC,EAAOlB,EACZiE,EAAK5B,EAAErC,EAEb+D,EAASrD,KAAK,CACZS,SAAUD,EAAOG,OACjB6C,QAAS7B,EAAEhB,OACX8C,GAAIX,EAAKrD,KAAKC,IAAI4D,GAClBI,GAAIZ,EAAKrD,KAAKG,IAAI0D,GAClBK,GAAIJ,EAAK9D,KAAKC,IAAI4D,GAClBM,GAAIL,EAAK9D,KAAKG,IAAI0D,GAClBrC,QAASU,EAAEV,OAEf,CACA,OAAOoC,CACT,CDpBeQ,CAAS/D,GACtBoD,EAAKY,KEVQ,SAAiBtC,GAC9B,MAAMF,EAAgB,EAAV7B,KAAK8B,GAKJ,IAAIG,IAAIF,EAAGT,IAAIY,GAAK,CAACA,EAAEhB,OAAQgB,KAC5C,MAAMoC,EAAmB,IAAIrC,IAC7B,IAAIG,EAAO,KAEX,IAAK,MAAMF,KAAKH,EACI,MAAdG,EAAElB,WAAkBoB,EAAOF,EAAEhB,QAC5BoD,EAAiBC,IAAIrC,EAAElB,WAAWsD,EAAiBzB,IAAIX,EAAElB,SAAU,IACxEsD,EAAiB9B,IAAIN,EAAElB,UAAUT,KAAK2B,GAGxC,MAAMmC,EAAO,GAEb,IAAK,MAAMtD,KAAUgB,EAAI,CACvB,MAAMyC,EAAMzD,EAAOG,OACnB,GAAIsD,IAAQpC,EAAM,SAClB,MAAMD,EAAOmC,EAAiB9B,IAAIgC,IAAQ,GAC1C,GAAIrC,EAAKzB,OAAS,EAAG,SAGrB,MAAM+D,EAAItC,EAAKb,IAAIoD,IAAUA,EAAEjD,MAvBPI,EAAOA,GAAOA,GAuBChB,KAAK,CAACa,EAAGC,IAAMD,EAAIC,GACpDgD,EAAOF,EAAE,GAAIG,EAAOH,EAAEA,EAAE/D,OAAS,GAGjCmE,EAASD,EAAOD,EAChBG,EAAUjD,EAAMgD,EAGtB,IAAIE,EAAOC,EAAKC,EACZJ,GAAUC,GACZC,EAAQJ,EACRK,EAAMJ,EACNK,EAAOJ,IAGPE,EAAQH,EACRI,EAAML,EACNM,EAAOH,GAGLG,EA1CM,OA0CSC,SAASnE,EAAOlB,IAAMkB,EAAOlB,GAAK,GAErDwE,EAAK9D,KAAK,CACRwE,QACAC,MACA7B,OAAQpC,EAAOlB,EACfqB,OAAQsD,EACRxD,SAAUD,EAAOC,UAErB,CAEA,OAAOqD,CACT,CF/Ccc,CAAQ1B,EAAKA,MACzBA,EAAK2B,WGPQ,SAAsBrD,GACnC,MAAMC,EAAO,IAAIC,IAAIF,EAAGT,IAAIY,GAAK,CAACA,EAAEhB,OAAQgB,KACtCmC,EAAO,GAEb,IAAK,MAAMf,KAASvB,EAAI,CACtB,GAAsB,MAAlBuB,EAAMtC,SAAkB,SAC5B,MAAMD,EAASiB,EAAKQ,IAAIc,EAAMtC,UACzBD,GAELsD,EAAK9D,KAAK,CACRS,SAAUD,EAAOG,OACjB6C,QAAST,EAAMpC,OACfiC,OAAQpC,EAAOlB,EACfkF,MAAOhE,EAAOU,MACduD,IAAK1B,EAAM7B,OAEf,CAEA,OAAO4C,CACT,CHZoBgB,CAAa5B,EAAKA,MAC7BA,CACT,CITe,SAAS6B,EAAcjF,GACpC,MAAM0B,EAAKpB,EAAQN,GAGbkF,EAAU,IAAItD,IAAIF,EAAGT,IAAI,CAACY,EAAG1B,IAAM,CAAC0B,EAAEhB,OAAQV,KAG9CgF,EAAU,IAChB,SAAUlD,EAAImD,GACPA,EAAEhF,UAAkC,IAAtBgF,EAAEhF,SAASC,OAC9B+E,EAAEhF,SAASmC,QAAQN,GAD2BkD,EAAQjF,KAAKkF,EAAEtE,GAE9D,CAHD,CAGGd,GAGH,MAAMqF,EAAU,IAAIzD,IAAIuD,EAAQlE,IAAI,CAACH,EAAIX,IAAM,CAACW,EAAIX,EAAI,KA2BxD,OAxBA,SAAUmF,EAAKF,GACb,MAAMjF,EAAI+E,EAAQ/C,IAAIiD,EAAEtE,IACxB,IAAKsE,EAAEhF,UAAkC,IAAtBgF,EAAEhF,SAASC,OAAc,CAC1C,MAAMR,EAAIwF,EAAQlD,IAAIiD,EAAEtE,IAExB,OADAY,EAAGvB,GAAGyD,GAAK/D,EAAG6B,EAAGvB,GAAG2D,GAAKjE,EAClBA,CACT,CACA,MACMA,EC7BK,SAAU0F,GACrB,IAAIC,EAAQ,EACRC,EAAM,EAEN,IAAK,IAAIC,KAASH,EACD,MAATG,IAAkBA,GAASA,IAAUA,MACnCF,EAAOC,GAAOC,GAW5B,GAAIF,EAAO,OAAOC,EAAMD,CAC5B,CDWcG,CADCP,EAAEhF,SAASa,IAAIqE,IAG1B,OADA5D,EAAGvB,GAAGyD,GAAK/D,EAAG6B,EAAGvB,GAAG2D,GAAKjE,EAClBA,CACR,CAXD,CAWGG,GAGH,SAAU4F,EAAKR,EAAGS,GAChB,MAAM1F,EAAI+E,EAAQ/C,IAAIiD,EAAEtE,IAElB6C,EAAKkC,GAAW,EAChBhC,EAAKF,GAFAjC,EAAGvB,GAAGe,cAAgB,GAGjCQ,EAAGvB,GAAGwD,GAAKA,EAAIjC,EAAGvB,GAAG0D,GAAKA,EACtBuB,EAAEhF,UAAYgF,EAAEhF,SAASC,QAAQ+E,EAAEhF,SAASmC,QAAQL,GAAK0D,EAAK1D,EAAG2B,GACtE,CAPD,CAOG7D,EAAM,GAGF0B,EAAGT,IAAK6E,IACb,MAAQjG,EAAGkG,EAAIrG,EAAGsG,EAAI5E,MAAO6E,KAAWC,GAASJ,EACjD,OAAOI,GAEX,CE3Ce,SAASC,EAAgBnG,GACtC,MAAMoD,EAAO6B,EAAcjF,GACrBoG,ECZO,SAAqBpG,GAClC,MAAMoD,EAAO6B,EAAcjF,GAGrBqG,EAAW,IAAIzE,IACrB,IAAK,MAAMkE,KAAO1C,EAAM,CACtB,GAAoB,MAAhB0C,EAAInF,SAAkB,SAC1B,MAAMU,EAAIgF,EAASlE,IAAI2D,EAAInF,UACvBU,EAAGA,EAAEnB,KAAK4F,GAAWO,EAAS7D,IAAIsD,EAAInF,SAAU,CAACmF,GACvD,CAEA,MAAMQ,EAAY,GAClB,IAAK,MAAO3F,EAAUmB,KAASuE,EAASE,UAAW,CACjD,IAAKzE,EAAKzB,OAAQ,SAElB,MAAMmG,EAAQ1E,EAAKb,IAAIY,GAAKA,EAAE+B,IACxBA,EAAKjE,KAAK8G,OAAOD,GACjB1C,EAAKnE,KAAK2C,OAAOkE,GAEjB9G,EAAIoC,EAAK,GAAG6B,GAElB2C,EAAUpG,KAAK,CACbS,WACAgD,GAAIjE,EACJmE,GAAInE,EACJkE,KACAE,KACA4C,QAAS5C,EAAKF,GAElB,CAEA,OAAO0C,CACT,CDpByBK,CAAY3G,GAC7B4G,EECO,SAA2B5G,GACxC,MAAMoD,EAAO6B,EAAcjF,GAGrB2B,EAAO,IAAIC,IAAIwB,EAAKnC,IAAIY,GAAK,CAACA,EAAEhB,OAAQgB,KAExCgF,EAAiB,GAEvB,IAAK,MAAMhF,KAAKuB,EAAM,CACpB,GAAkB,MAAdvB,EAAElB,SAAkB,SACxB,MAAMD,EAASiB,EAAKQ,IAAIN,EAAElB,UAC1B,IAAKD,EAAQ,SAEb,MAAMhB,EAAImC,EAAE8B,GACNmD,EAAKjF,EAAE+B,GACPmD,EAAKrG,EAAOkD,GACZA,EAAKjE,KAAK8G,IAAIK,EAAIC,GAClBjD,EAAKnE,KAAK2C,IAAIwE,EAAIC,GAExBF,EAAe3G,KAAK,CAClBS,SAAUkB,EAAElB,SACZ+C,QAAS7B,EAAEhB,OACXnB,IACAkE,KACAE,MAEJ,CAEA,OAAO+C,CACT,CF9B+BG,CAAkBhH,GAGlC,IAAI4B,IAAIwB,EAAKnC,IAAIY,GAAK,CAACA,EAAEhB,OAAQgB,KAC9C,MAAMoF,EAAmB7D,EACtB8D,OAAOrF,GAAmB,MAAdA,EAAElB,UACdM,IAAIY,IAAC,CACJlB,SAAUkB,EAAElB,SACZ+C,QAAS7B,EAAEhB,OACXA,OAAQgB,EAAEhB,OACVE,UAAWc,EAAEd,UACbI,MAAOU,EAAEV,MACTwC,GAAI9B,EAAE8B,GACNE,GAAIhC,EAAEgC,GACND,GAAI/B,EAAE+B,GACNE,GAAIjC,EAAE+B,MAGV,MAAO,CAAER,OAAMgD,iBAAgBQ,uBAAsBK,mBACvD,CGZA,SAASE,EAAiBnH,GACJ,OAAhBA,EAAKU,SAbT,SAAU0G,EAAKhC,GACb,IAAKA,EAAEhF,UAAkC,IAAtBgF,EAAEhF,SAASC,OACf,OAAb+E,EAAEiC,MAAQ,EAAU,EAEtB,IAAI5B,EAAM,EACV,IAAK,MAAMvD,KAAKkD,EAAEhF,SAAUqF,GAAO2B,EAAKlF,GAExC,OADAkD,EAAEiC,MAAQ5B,EACHA,CACR,CARD,CAcoBzF,GAClBA,EAAK0E,MAAQ,EACb1E,EAAK2E,IAAM,EACX3E,EAAKoB,MAAQ,EACbpB,EAAKqH,MCRM,SAASC,GACtB,IAAIC,EAAS,EACb,IAAK,MAAMvH,KAjBb,SAAoB+B,GAClB,MAAMyF,EAAQ,CAACzF,GAAOwF,EAAS,GAC/B,KAAOC,EAAMnH,QAAQ,CACnB,MAAMoH,EAAUD,EAAME,QACtBH,EAAOrH,KAAKuH,GACZ,IAAK,MAAMxE,KAASwE,EAAQrH,SAAUoH,EAAMtH,KAAK+C,EACnD,CACA,OAAOsE,CACT,CASqBI,CAAWL,GACA,GAAxBtH,EAAKI,SAASC,QAAakH,IAEjC,QACF,CDEiBK,CAAQ5H,GACrBA,EAAKN,EAAI,EACTM,EAAKH,EAAI,GAGX,IAAIgI,EAAY7H,EAAK0E,MAErB,IAAK,IAAIvE,EAAI,EAAGA,EAAIH,EAAKI,SAASC,OAAQF,IAAK,CAC7C,MAAM8C,EAAQjD,EAAKI,SAASD,GACtB2H,GAAO9H,EAAK2E,IAAM3E,EAAK0E,QAAUzB,EAAMoE,MAAQrH,EAAKqH,OAE1DpE,EAAMyB,MAAQmD,EACd5E,EAAM0B,IAAMkD,EAAYC,EAGxB7E,EAAM7B,MAAQ6B,EAAMyB,OAASzB,EAAM0B,IAAM1B,EAAMyB,OAAS,EACxDmD,EAAY5E,EAAM0B,IAGlB,MAAMnB,EAAQP,EAAM7B,MAAQzB,KAAK8B,GAC3ByB,EAAMD,EAAM/B,cAAgB,EAClC+B,EAAMvD,EAAIM,EAAKN,EAAIwD,EAAKvD,KAAKG,IAAI0D,GACjCP,EAAMpD,EAAIG,EAAKH,EAAIqD,EAAKvD,KAAKC,IAAI4D,GAEjC2D,EAAiBlE,EACnB,CAEA,OAAOjD,CACT,CEhDe,SAAA+H,EAAU/H,GACvB,IAAIoD,EAAO,CAAA,EAEP4E,EAAK1H,EAAQ6G,EAAiBnH,IAKlC,OAJAoD,EAAKA,KAAO4E,EAEZ5E,EAAK6E,MCRQ,SAAexH,EAAIyH,GAAc,GAC9C,MAAMC,EAAO,IAAI1H,GAAID,KAAK,CAACa,EAAGC,IAAMD,EAAER,OAASS,EAAET,QAC3Cc,EAAO,IAAIC,IAAIuG,EAAKlH,IAAKzB,GAAM,CAACA,EAAEqB,OAAQrB,KAC1C+H,EAAS,GAEf,IAAK,MAAMzB,KAAOqC,EAAM,CACtB,GAAoB,MAAhBrC,EAAInF,SAAkB,SAC1B,MAAMD,EAASiB,EAAKQ,IAAI2D,EAAInF,UACvBD,IAEDwH,GACFX,EAAOrH,KAAK,CAAE2D,GAAIiC,EAAIpG,EAAGoE,GAAIgC,EAAIjG,EAAGuI,IAAKtC,EAAIjF,OAAQwH,GAAI3H,EAAOhB,EAAG4I,GAAIxC,EAAIjG,EAAG0I,SAAKC,IACnFjB,EAAOrH,KAAK,CAAE2D,GAAInD,EAAOhB,EAAGoE,GAAIgC,EAAIjG,EAAGuI,SAAKI,EAAWH,GAAI3H,EAAOhB,EAAG4I,GAAI5H,EAAOb,EAAG0I,IAAKzC,EAAInF,YAE5F4G,EAAOrH,KAAK,CAAE2D,GAAIiC,EAAIpG,EAAGoE,GAAIgC,EAAIjG,EAAGuI,IAAKtC,EAAIjF,OAAQwH,GAAI3H,EAAOhB,EAAG4I,GAAI5H,EAAOb,EAAG0I,IAAKzC,EAAInF,WAE9F,CACA,OAAO4G,CACT,CDVeU,CAAMD,GAEZ5E,CACT,CERe,SAASqF,EAASC,GAI/B,MAAMC,GAFND,EAAOE,OAAOF,GAAMG,QAAQ,OAAQ,KAEhBC,MAAM,eACpB/G,EAAO,CAAErB,OAAQ,KAAMN,SAAU,IACvC,IAAIqH,EAAU1F,EACVgH,EAAS,EAEb,IAAK,MAAMC,KAASL,EAClB,GAAKK,GAAmB,MAAVA,EAEd,GAAc,MAAVA,EAAe,CACjB,MAAM/F,EAAQ,CAAEvC,OAAQ+G,EAASrH,SAAU,IAC3CqH,EAAQrH,SAASF,KAAK+C,GACtBwE,EAAUxE,CACZ,MAAO,GAAc,MAAV+F,EAAe,CAExBvB,EAAUA,EAAQ/G,OAClB,MAAMuC,EAAQ,CAAEvC,OAAQ+G,EAASrH,SAAU,IAC3CqH,EAAQrH,SAASF,KAAK+C,GACtBwE,EAAUxE,CACZ,MAAO,GAAc,MAAV+F,GAGT,GADAvB,EAAUA,EAAQ/G,OACF,OAAZ+G,EAAkB,UACjB,CAEL,MAAMwB,EAAWD,EAAMF,MAAM,KACL,IAApBG,EAAS5I,OACP2I,EAAME,WAAW,MACnBzB,EAAQzG,MAAQ,GAChByG,EAAQvG,aAAeiI,WAAWF,EAAS,MAE3CxB,EAAQzG,MAAQiI,EAAS,GACzBxB,EAAQvG,aAAe,MAEI,IAApB+H,EAAS5I,QAClBoH,EAAQzG,MAAQiI,EAAS,GACzBxB,EAAQvG,aAAeiI,WAAWF,EAAS,MAE3CG,QAAQC,KAAKL,EAAO,gDACpBvB,EAAQzG,MAAQiI,EAAS,IAAM,GAC/BxB,EAAQvG,aAAeiI,WAAWF,EAASA,EAAS5I,OAAS,KAE/DoH,EAAQ3G,GAAKiI,GACf,CAMF,OAFe,MAAXhH,EAAKjB,KAAYiB,EAAKjB,GAAKiI,GAExBhH,CACT,QC3De,SACbuH,GACAC,OACEA,EAAS,OAAMC,MACfA,EAAQ,IAAGC,OACXA,EAAS,IAAGC,OACZA,EAAS,CAAEC,IAAK,GAAIC,MAAO,IAAKC,OAAQ,GAAIC,KAAM,IAAIC,aACtDA,EAAe,GAAEC,YACjBA,EAAc,EAACC,WACfA,EAAa,SACX,CAAA,GAEJ,GAAe,SAAXV,EAAmB,CAErB,MAAMW,EAAUC,EAAmBC,EAAYd,IACzCe,EAAaH,EAAQjD,iBACrBqD,EAAWJ,EAAQ9D,eACnBmE,EAAOF,EAAWnD,OAAQrF,GAAMA,EAAEV,OAElCqJ,EAAOC,EAAGnI,IAAI+H,EAAaxI,GAAMA,EAAEiC,IACnC4G,EAAOD,EAAGhE,IAAI4D,EAAaxI,GAAMA,EAAEiC,IACnC6G,EAAOF,EAAGnI,IAAI+H,EAAaxI,GAAMA,EAAEgC,IAEnC+G,EAASH,EACZI,cACAC,OAAO,CAACJ,EAAO,EAAGF,EAAO,IACzBO,MAAM,CAACrB,EAAOC,IAAKF,EAASC,EAAOG,SAEhCmB,EAASP,EACZI,cACAC,OAAO,CAAC,EAAGH,IACXI,MAAM,CAACrB,EAAOI,KAAMN,EAAQE,EAAOE,QAEhCqB,EAAMR,EACTS,OAAO,OACPC,KAAK,QAAS3B,GACd2B,KAAK,SAAU1B,GACf0B,KAAK,cAAe,cACpBA,KAAK,YAAa,IAEfC,EAAQH,EAAII,OAAO,KA4CzB,OA1CAD,EACGE,UAAU,UACVlI,KAAKiH,GACLkB,KAAK,QACLJ,KAAK,KAAOtJ,GAAMmJ,EAAOnJ,EAAE8B,KAC3BwH,KAAK,KAAOtJ,GAAM+I,EAAO/I,EAAE+B,KAC3BuH,KAAK,KAAOtJ,GAAMmJ,EAAOnJ,EAAEgC,KAC3BsH,KAAK,KAAOtJ,GAAM+I,EAAO/I,EAAEiC,KAC3BqH,KAAK,SAAU,QACfA,KAAK,eAAgBnB,GAExBoB,EACGE,UAAU,UACVlI,KAAKkH,GACLiB,KAAK,QACLJ,KAAK,KAAOtJ,GAAMmJ,EAAOnJ,EAAE8B,KAC3BwH,KAAK,KAAOtJ,GAAM+I,EAAO/I,EAAE+B,KAC3BuH,KAAK,KAAOtJ,GAAMmJ,EAAOnJ,EAAEgC,KAC3BsH,KAAK,KAAOtJ,GAAM+I,EAAO/I,EAAEiC,KAC3BqH,KAAK,SAAU,QACfA,KAAK,eAAgBnB,GAExBoB,EACGE,UAAU,YACVlI,KAAKmH,GACLgB,KAAK,UACLJ,KAAK,KAAOtJ,GAAMmJ,EAAOnJ,EAAEgC,KAC3BsH,KAAK,KAAOtJ,GAAM+I,EAAO/I,EAAEiC,KAC3BqH,KAAK,IAAK,GACVA,KAAK,OAAQ,SAEhBF,EACGI,OAAO,KACPC,UAAU,QACVlI,KAAKmH,GACLgB,KAAK,QACLJ,KAAK,IAAMtJ,GAAMmJ,EAAOnJ,EAAEgC,IAAM,GAChCsH,KAAK,IAAMtJ,GAAM+I,EAAO/I,EAAEiC,KAC1BqH,KAAK,KAAM,UACXA,KAAK,YAAa,IAClBzC,KAAM7G,GAAMA,EAAEd,WAAW8H,QAAQ,KAAM,MAAQ,IAE3CoC,EAAIjL,MACb,CAAO,GAAe,WAAXuJ,EAAqB,CAK9B,MACMiC,EAAMC,EADOrB,EAAYd,IAKzBoC,EAAuB,UADZzB,EAOX0B,EAAQ,EACRC,EAAU,EAIVC,GADYpB,EAAGnI,IAAIkJ,EAAIpI,KAAOvB,GAAMA,EAAErC,IAAM,GAClB,EAAIuK,EAC9B+B,EAAItC,EACRuC,EAAItC,EACAuC,EAAUF,EAAI,EAClBG,EAAUF,EAAI,EAEVG,EAAezB,EAClBI,cACAC,OAAO,EAAEe,EAAaA,IACtBd,MAAM,CAAC,EAAGe,IACPK,EAAe1B,EAClBI,cACAC,OAAO,EAAEe,EAAaA,IACtBd,MAAM,CAACgB,EAAG,IACPK,EAAY5M,GAAMA,GAAKsM,GAAK,EAAID,IAGhClK,EAAO,IAAIC,IAAI4J,EAAIpI,KAAKnC,IAAKY,GAAM,CAACA,EAAEhB,OAAQgB,KAC9C0I,EAAOiB,EAAIpI,KAAK8D,OAAQrF,GAAMA,EAAEV,OAChCkL,EAAU9B,EAAKlK,OAASoK,EAAGnI,IAAIiI,EAAO1I,GAAMA,EAAErC,GAAK,EASzD,SAAS8M,EAAe3I,EAAIC,EAAIC,EAAIC,GAClC,MAAMyI,EAAKL,EAAavI,GACtB6I,EAAKL,EAAavI,GAGd6I,EAFKP,EAAarI,GAER0I,EACdG,EAFKP,EAAarI,GAER0I,EACNG,EAAMhN,KAAKiN,MAAMH,EAAIC,IAAO,EAC5BjN,EAAIE,KAAK2C,IAAI,GAAIqK,EAAMf,GAAWe,GACxC,MAAO,CAAEJ,KAAIC,KAAIK,IAAKN,EAAKE,EAAKhN,EAAGqN,IAAKN,EAAKE,EAAKjN,EAAGkN,MACvD,CAGA,MAAM1B,EAAMR,EACTS,OAAO,OACPC,KAAK,QAASW,GACdX,KAAK,SAAUY,GACfZ,KAAK,cAAe,cACpBA,KAAK,YAAa,IAEfC,EAAQH,EAAII,OAAO,KA0HzB,OAvHAD,EACGC,OAAO,KACPF,KAAK,QAAS,cACdG,UAAU,QACVlI,KAAKoI,EAAIxH,MACTuH,KAAK,QACLJ,KAAK,IAAMtJ,GC/JH,SAAqBvC,EAAIC,EAAIuD,EAAQiK,EAAYC,GAC9D,MAAMxL,EAAgB,EAAV7B,KAAK8B,GACXwL,EAAQxN,IAAQA,EAAI+B,EAAOA,GAAOA,EACxC,IAAI0L,EAAKD,EAAKF,GACVI,EAAKF,EAAKD,GAOd,IAHYE,EAAKC,EAAK3L,GAAOA,GADhB2L,EAAKD,EAAK1L,GAAOA,EAIhB,CACZ,MAAM4L,EAAMF,EAAIA,EAAKC,EAAIA,EAAKC,CAChC,CAEA,MAAMC,GAASF,EAAKD,EAAK1L,GAAOA,EAChC,GAAI6L,EAAQ,KAAM,CAChB,MAAMC,EAAIjO,EAAiBC,EAAIC,EAAIuD,EAAQoK,GAC3C,MAAO,KAAKI,EAAE5N,KAAK4N,EAAEzN,GACvB,CAEA,MAAM0N,EAAeF,EAAQ1N,KAAK8B,GAAK,EAAI,EAGrC+L,EAAKnO,EAAiBC,EAAIC,EAAIuD,EAAQoK,GACtCO,EAAKpO,EAAiBC,EAAIC,EAAIuD,EAAQqK,GAE5C,MAAO,KAAKK,EAAG9N,KAAK8N,EAAG3N,OAAOiD,KAAUA,OAAYyK,OAA6BE,EAAG/N,KAAK+N,EAAG5N,GAC9F,CDoIQ6N,CACE1B,EACAC,EACAtM,KAAK2C,IAAI,EAAG8J,EAASvK,EAAEiB,SACvBjB,EAAE6C,MACF7C,EAAE8C,MAGLwG,KAAK,OAAQ,QACbA,KAAK,SAAU,QACfA,KAAK,eAAgBnB,GAGxBoB,EACGC,OAAO,KACPF,KAAK,QAAS,eACdG,UAAU,QACVlI,KAAKoI,EAAInI,OACTkI,KAAK,QACLoC,KAAK,SAASC,EAAGC,GAEhB,MAAMlK,EAAKiK,EAAEjK,GACXC,EAAKgK,EAAEhK,GAGHkK,GA7DSC,EA6DOH,GA3DXlK,SAAWqK,EAAMlN,QAAUkN,EAAM3F,KAAO,KAFvD,IAAmB2F,EA8Df,MAAM/N,EAAc,MAAP8N,EAAcnM,EAAKQ,IAAI2L,QAAOtF,EACrCwF,KAAgBhO,IAAQA,EAAKmB,OAGnC,IAAI0C,EAAK+J,EAAE/J,GACTC,EAAK8J,EAAE9J,GAGL4H,GAAWsC,IACbnK,EAAKwI,EAAU1M,KAAKC,IAAII,EAAKoB,OAC7B0C,EAAKuI,EAAU1M,KAAKG,IAAIE,EAAKoB,QAI/B,MAAMmL,GAAEA,EAAEC,GAAEA,EAAEK,IAAEA,EAAGC,IAAEA,GAAcR,EAAe3I,EAAIC,EAAIC,EAAIC,GAE9D2G,EAAGwD,OAAOC,MACP/C,KAAK,KAAMoB,GACXpB,KAAK,KAAMqB,GACXrB,KAAK,KAAM0B,GACX1B,KAAK,KAAM2B,GACX3B,KAAK,SAAU,QACfA,KAAK,eAAgBnB,EAC1B,GAGFoB,EACGC,OAAO,KACPF,KAAK,QAAS,kBACdG,UAAU,UACVlI,KAAKmH,GACLgB,KAAK,UACLoC,KAAK,SAAS9L,EAAGgM,GAEhB,MAAMnO,EAAIgM,EAAUW,EAAU1M,KAAKC,IAAIiC,EAAET,OAASS,EAAEnC,EAC9CG,EAAI6L,EAAUW,EAAU1M,KAAKG,IAAI+B,EAAET,OAASS,EAAEhC,EAEpD4K,EAAGwD,OAAOC,MACP/C,KAAK,KAAMe,EAAaxM,IACxByL,KAAK,KAAMgB,EAAatM,IACxBsL,KAAK,IAAKQ,GACVR,KAAK,OAAQ,SACbA,KAAK,SAAU,SACfA,KAAK,eAAgB,IAC1B,GAIFC,EACGC,OAAO,KACPF,KAAK,QAAS,gBACdG,UAAU,WACVlI,KAAKmH,GACLgB,KAAK,KACLJ,KAAK,QAAS,SACdA,KAAK,YAActJ,IAIlB,MAAMrC,EAAIkM,EAAUW,EAAUxK,EAAErC,EAC1BE,EAAIF,EAAIG,KAAKC,IAAIiC,EAAET,OACnBvB,EAAIL,EAAIG,KAAKG,IAAI+B,EAAET,OACzB,MAAO,aAAa8K,EAAaxM,MAAMyM,EAAatM,QAErD8N,KAAK,SAAS9L,GAEb,IAAIT,EAAoB,KAAVS,EAAET,MAAezB,KAAK8B,GAChC0M,EAAO,GACPC,EAAS,QACTvM,EAAET,MAAQzB,KAAK8B,GAAK,GAAKI,EAAET,MAAS,EAAIzB,KAAK8B,GAAM,IACrDL,GAAS,IACT+M,IAAQ,EACRC,EAAS,OAEX3D,EAAGwD,OAAOC,MACP7C,OAAO,KACPF,KAAK,YAAa,UAAU/J,MAC5BiK,OAAO,QACPF,KAAK,IAAKgD,GACVhD,KAAK,qBAAsB,UAC3BA,KAAK,cAAeiD,GACpBjD,KAAK,YAAa,IAClBA,KAAK,OAAQ,SACbzC,KAAM7G,GAAMA,EAAEd,WAAW8H,QAAQ,KAAM,MAAQ,GACpD,GAEKoC,EAAIjL,MACb,CAAO,GAAe,aAAXuJ,EAAuB,CAEhC,MACM8E,EAAgBC,EADHlE,EAAYd,IAGzBwC,EAAItC,EACJuC,EAAItC,EAGJ8E,EAAU9D,EAAG+D,OAAOH,EAAcjL,KAAOvB,GAAMA,EAAEnC,GACjD+O,EAAUhE,EAAG+D,OAAOH,EAAcjL,KAAOvB,GAAMA,EAAEhC,GAGjD8K,EAAOhL,KAAK2C,IAAI3C,KAAK+O,IAAIH,EAAQ,IAAK5O,KAAK+O,IAAIH,EAAQ,KACvD/D,EAAO7K,KAAK2C,IAAI3C,KAAK+O,IAAID,EAAQ,IAAK9O,KAAK+O,IAAID,EAAQ,KAIvDE,EAHYhP,KAAK2C,IAAIqI,EAAMH,GAGD,EAAIT,EAE9B6E,EAAenE,EAClBI,cACAC,OAAO,EAAE6D,EAAaA,IACtB5D,MAAM,CAAC,EAAGe,IAEP+C,EAAepE,EAClBI,cACAC,OAAO,EAAE6D,EAAaA,IACtB5D,MAAM,CAACgB,EAAG,IAEPd,EAAMR,EACTS,OAAO,OACPC,KAAK,QAASW,GACdX,KAAK,SAAUY,GACfZ,KAAK,cAAe,cACpBA,KAAK,YAAa,IAEfC,GAAQH,EAAII,OAAO,KAGzBD,GACGC,OAAO,KACPF,KAAK,QAAS,eACdG,UAAU,QACVlI,KAAKiL,EAAcpG,OACnBsD,KAAK,QACLJ,KAAK,KAAOtJ,GAAM+M,EAAa/M,EAAEgC,KACjCsH,KAAK,KAAOtJ,GAAMgN,EAAahN,EAAEiC,KACjCqH,KAAK,KAAOtJ,GAAM+M,EAAa/M,EAAEwG,KACjC8C,KAAK,KAAOtJ,GAAMgN,EAAahN,EAAEyG,KACjC6C,KAAK,eAAgBnB,GACrBmB,KAAK,SAAU,QAGlBC,GACGC,OAAO,KACPF,KAAK,QAAS,gBACdG,UAAU,UACVlI,KAAKiL,EAAcjL,MACnBmI,KAAK,UACLJ,KAAK,QAAS,OACdA,KAAK,IAAMtJ,GAAOA,EAAEV,MAAQ,EAAI,GAChCgK,KAAK,KAAOtJ,GAAM+M,EAAa/M,EAAEnC,IACjCyL,KAAK,KAAOtJ,GAAMgN,EAAahN,EAAEhC,IACjCsL,KAAK,SAAU,SACfA,KAAK,eAAgB,GACrBA,KAAK,OAAStJ,GAAOA,EAAEV,MAAQ,QAAU,SAG5C,MAAM2N,GAAW,IAAIlN,IACfmN,GAAY,IAAInN,IAAIyM,EAAcjL,KAAKnC,IAAKY,GAAM,CAACA,EAAEhB,OAAQgB,KA+DnE,OA7DAwM,EAAcpG,MAAM1F,QAASyM,IAC3B,MAAMC,EAAUF,GAAU5M,IAAI6M,EAAK5G,KAC/B6G,GAAS9N,OACX2N,GAAStM,IAAIwM,EAAK5G,IAAK4G,KAI3B5D,GACGC,OAAO,KACPF,KAAK,QAAS,gBACdG,UAAU,KACVlI,KAAKiL,EAAcjL,KAAK8D,OAAQrF,GAAMA,EAAEV,QACxCoK,KAAK,KACLJ,KAAK,YAActJ,GAGX,aAFG+M,EAAa/M,EAAEnC,MACfmP,EAAahN,EAAEhC,OAG1B8N,KAAK,SAAS9L,GACb,MAAMmN,EAAOF,GAAS3M,IAAIN,EAAEhB,QAC5B,IAAKmO,EAMH,YALA5F,QAAQC,KACN,uCACAxH,EAAEhB,OACFgB,EAAEd,WAMN,MAAM8C,EAAK+K,EAAaI,EAAKnL,IACvBC,EAAK+K,EAAaG,EAAKlL,IAIvB2I,EAHKmC,EAAaI,EAAK3G,IAGbxE,EACV6I,EAHKmC,EAAaG,EAAK1G,IAGbxE,EAChB,IAAI1C,EAA8B,IAArBzB,KAAKkD,MAAM6J,EAAID,GAAa9M,KAAK8B,GAG1CyN,GAAU,GACVd,EAAS,OACThN,EAAQ,IAAMA,SAChBA,GAAS,IACTgN,EAAS,QACTc,EAAU,IAIZzE,EAAGwD,OAAOC,MACP7C,OAAO,KACPF,KAAK,YAAa,UAAU/J,MAC5BiK,OAAO,QACPF,KAAK,IAAK+D,GACV/D,KAAK,qBAAsB,UAC3BA,KAAK,cAAeiD,GACpBjD,KAAK,YAAa,IAClBA,KAAK,OAAQ,SACbzC,KAAK7G,EAAEd,WAAW8H,QAAQ,KAAM,MAAQ,GAC7C,GAEKoC,EAAIjL,MACb,CACE,MAAM,IAAImP,MAAM,mDAEpB"}
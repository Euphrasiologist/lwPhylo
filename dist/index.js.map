{"version":3,"file":"index.js","sources":["../src/phisheye/phisheye.js","../src/radial/polarToCartesian.js","../src/radial/describeArc.js","../src/utils/preorder.js","../src/utils/fortify.js","../src/radial/radialData.js","../src/radial/radialLayout.js","../src/radial/getRadii.js","../src/radial/getArcs.js","../src/rectangle/getHorizontal.js","../src/utils/mean.js","../src/rectangle/rectangleLayout.js","../src/rectangle/getVertical.js","../src/rectangle/getChildVerticals.js","../src/unrooted/equalAngleLayout.js","../src/utils/numTips.js","../src/unrooted/unrooted.js","../src/utils/edges.js","../src/utils/parentFisheye.js","../src/utils/readTree.js","../src/utils/subTree.js"],"sourcesContent":["// Based on the archived d3 fisheye plugin, modernized & hardened.\n// - Works in screen/pixel space (set xscale/yscale).\n// - O(1) math with precomputed constants; avoids unnecessary sqrt.\n// - Stable API: .radius(), .distortion(), .focus(), .scales()\n// - Returns { x, y, z } where z ~= local magnification (clamped).\n// - Adds small ergonomics: .setScales(), .focusFromEvent(), .clampZ()\n\nconst phisheye = {\n  circular: () => {\n    let radius = 200;        // pixels\n    let distortion = 2;      // dimensionless\n    let focus = [0, 0];      // [fx, fy] in pixels\n    let scales = {};         // { xscale, yscale }\n    let k0 = 0, k1 = 0;      // precomputed factors\n    let radius2 = radius * radius;\n    let zClamp = 10;         // max z (magnification) for stability\n\n    function ensureScales() {\n      if (!scales || typeof scales.xscale !== \"function\" || typeof scales.yscale !== \"function\") {\n        throw new Error(\"phisheye.circular: call .scales(xscale, yscale) before using the fisheye.\");\n      }\n    }\n\n    function rescale() {\n      // Same functional form as the classic plugin:\n      // k = ((e^d) / (e^d - 1)) * R * (1 - exp(-d * r / R)) / r\n      // where d=distortion, R=radius, r=distance to focus.\n      const e = Math.exp(distortion);\n      k0 = (e / (e - 1)) * radius;  // constant multiplier\n      k1 = distortion / radius;     // exponent scale\n      radius2 = radius * radius;\n      return fisheye;\n    }\n\n    function fisheye(d) {\n      ensureScales();\n\n      const x0 = scales.xscale(d.x);\n      const y0 = scales.yscale(d.y);\n\n      const dx = x0 - focus[0];\n      const dy = y0 - focus[1];\n      const dd2 = dx * dx + dy * dy;\n\n      // At the focus or outside radius -> identity mapping, z ~ 1\n      if (dd2 === 0 || dd2 >= radius2) {\n        return { x: x0, y: y0, z: dd2 >= radius2 ? 1 : zClamp };\n      }\n\n      const dd = Math.sqrt(dd2);\n      // Classic mapping (with a slight blend for gentler core)\n      const k = ((k0 * (1 - Math.exp(-dd * k1))) / dd) * 0.75 + 0.25;\n\n      // New position\n      const x = focus[0] + dx * k;\n      const y = focus[1] + dy * k;\n\n      // Local magnification proxy (clamped)\n      const z = Math.min(k, zClamp);\n\n      return { x, y, z };\n    }\n\n    // --- Public API ---\n\n    fisheye.radius = function(_) {\n      if (!arguments.length) return radius;\n      radius = Math.max(0, +_);\n      return rescale();\n    };\n\n    fisheye.distortion = function(_) {\n      if (!arguments.length) return distortion;\n      distortion = Math.max(0, +_);\n      return rescale();\n    };\n\n    fisheye.focus = function(_) {\n      if (!arguments.length) return focus.slice();\n      if (!Array.isArray(_) || _.length !== 2) throw new Error(\"focus expects [x, y] in pixels.\");\n      focus = [+_[0], +_[1]];\n      return fisheye;\n    };\n\n    fisheye.scales = function(xscale, yscale) {\n      if (!arguments.length) return scales;\n      scales = { xscale, yscale };\n      return fisheye;\n    };\n\n    // Convenience alias\n    fisheye.setScales = fisheye.scales;\n\n    // Clamp maximum z (magnification) returned; defaults to 10\n    fisheye.clampZ = function(_) {\n      if (!arguments.length) return zClamp;\n      zClamp = Math.max(1, +_);\n      return fisheye;\n    };\n\n    // Convenience: set focus from a pointer event relative to an HTMLElement/SVG\n    // Example: svg.on(\"pointermove\", (e) => fe.focusFromEvent(e, svg.node()))\n    fisheye.focusFromEvent = function(event, element) {\n      const rect = element.getBoundingClientRect();\n      const fx = event.clientX - rect.left;\n      const fy = event.clientY - rect.top;\n      return fisheye.focus([fx, fy]);\n    };\n\n    return rescale();\n  }\n};\n\nexport default phisheye;\n\n","import polarToCartesian from \"./polarToCartesian.js\";\n\n/**\n * Draw the shortest arc between startAngle and endAngle on a circle.\n * - Angles are radians.\n * - Works with Y-inverted screen coords (our polarToCartesian already inverts Y).\n * - Automatically picks CW or CCW sweep to follow the *shorter* path.\n */\nexport default function describeArc(cx, cy, radius, startAngle, endAngle) {\n  const TAU = Math.PI * 2;\n  const norm = (t) => ((t % TAU) + TAU) % TAU;\n\n  const a0 = norm(startAngle);\n  const a1 = norm(endAngle);\n\n  // CCW delta (a0 -> a1), and CW delta (a0 -> a1 going the other way)\n  const ccw = (a1 - a0 + TAU) % TAU;\n  const cw  = (a0 - a1 + TAU) % TAU;\n\n  // Choose the shorter sweep\n  const sweepFlag = cw < ccw ? 1 : 0;         // 1 = CW, 0 = CCW (SVG spec)\n  const delta = Math.min(ccw, cw);\n  const largeArcFlag = delta > Math.PI ? 1 : 0;\n\n  // If degenerate, just move to the point\n  if (delta < 1e-9) {\n    const p = polarToCartesian(cx, cy, radius, a0);\n    return `M ${p.x} ${p.y}`;\n  }\n\n  // Use the original angles; sweepFlag picks direction\n  const p0 = polarToCartesian(cx, cy, radius, a0);\n  const p1 = polarToCartesian(cx, cy, radius, a1);\n\n  return `M ${p0.x} ${p0.y} A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${p1.x} ${p1.y}`;\n}\n\n","import polarToCartesian from \"./polarToCartesian.js\"\n\nexport default function describeArc(cx, cy, radius, startAngle, endAngle) {\n  const TAU = Math.PI * 2;\n  const norm = (t) => ((t % TAU) + TAU) % TAU;\n\n  let a0 = norm(startAngle);\n  let a1 = norm(endAngle);\n\n  // delta in the *clockwise* direction (increasing angle after Y inversion)\n  let delta = a1 - a0;\n  if (delta < 0) delta += TAU;\n\n  const largeArcFlag = delta > Math.PI ? 1 : 0;\n  const sweepFlag = 1; // CLOCKWISE sweep to match getArcs' start→end\n\n  const start = polarToCartesian(cx, cy, radius, a0);\n  const end   = polarToCartesian(cx, cy, radius, a1);\n\n  return [\n    \"M\", start.x, start.y,\n    \"A\", radius, radius, 0, largeArcFlag, sweepFlag, end.x, end.y\n  ].join(\" \");\n}\n\n","/**\n * Recursive function for pre-order traversal of tree (returns array)\n */\nexport function preorder(node, list = []) {\n  list.push(node);\n  for (let i = 0; i < (node.children?.length || 0); i++) {\n    list = preorder(node.children[i], list);\n  }\n  return list;\n}\n\n/**\n * Iterative generator traversals (avoid recursion limits on large trees)\n */\nexport function* preorderIter(root) {\n  const stack = [root];\n  while (stack.length) {\n    const n = stack.pop();\n    yield n;\n    if (n.children) for (let i = n.children.length - 1; i >= 0; --i) stack.push(n.children[i]);\n  }\n}\n\nexport function* postorderIter(root) {\n  const stack = [[root, 0]];\n  while (stack.length) {\n    const top = stack[stack.length - 1];\n    const [n, i] = top;\n    if (!n.children || i >= n.children.length) {\n      stack.pop();\n      yield n;\n    } else {\n      top[1] = i + 1;\n      stack.push([n.children[i], 0]);\n    }\n  }\n}\n\n","import { preorder } from \"./preorder.js\"\n\n/**\n * Convert parsed Newick tree from readTree() into data\n * frame.\n * this is akin to a \"phylo\" object in R.\n */\n\nexport default function (tree, sort = true) {\n    var df = [];\n\n    for (const node of preorder(tree)) {\n        if (node.parent === null) {\n            df.push({\n                'parentId': null,\n                'parentLabel': null,\n                'thisId': node.id,\n                'thisLabel': node.label,\n                'children': node.children.map(x => x.id),\n                'branchLength': 0.,\n                'isTip': false,\n                'x': node.x,\n                'y': node.y,\n                'angle': node.angle\n            })\n        }\n        else {\n            df.push({\n                'parentId': node.parent.id,\n                'parentLabel': node.parent.label,\n                'thisId': node.id,\n                'thisLabel': node.label,\n                'children': node.children.map(x => x.id),\n                'branchLength': node.branchLength,\n                'isTip': (node.children.length == 0),\n                'x': node.x,\n                'y': node.y,\n                'angle': node.angle\n            })\n        }\n    }\n\n    if (sort) {\n        df = df.sort(function (a, b) {\n            return a.thisId - b.thisId;\n        })\n    }\n    return (df);\n}\n","import fortify from \"../utils/fortify.js\"\n\n/**\n * Compute per-node polar coordinates for radial layout:\n *  - Tip angles: evenly spaced 0..2π in tip DFS order\n *  - Internal angles: circular mean of child angles\n *  - Radii: cumulative branch length from root\n *  - x,y: cartesian projection\n *\n * Returns the fortified array with added {angle, r, x, y}.\n */\nexport default function radialData(node) {\n  const TAU = Math.PI * 2;\n  const norm = (t) => ((t % TAU) + TAU) % TAU;\n\n  const pd = fortify(node, /*sort*/ true);\n  const byId = new Map(pd.map(d => [d.thisId, d]));\n  const kids = new Map(pd.map(d => [d.thisId, d.children || []]));\n\n  // Find root id\n  let root = null;\n  for (const d of pd) {\n    if (d.parentId == null) { root = d.thisId; break; }\n  }\n\n  // Collect tip ids in DFS left->right order to preserve input ordering\n  const tipIds = [];\n  (function dfs(id) {\n    const c = kids.get(id) || [];\n    if (c.length === 0) {\n      tipIds.push(id);\n      return;\n    }\n    for (const ch of c) dfs(ch);\n  })(root);\n\n  // Assign tip angles evenly spaced 0..2π\n  const N = Math.max(1, tipIds.length);\n  const angle = new Map();\n  tipIds.forEach((id, i) => {\n    angle.set(id, (i / N) * TAU);\n  });\n\n  // Internal node angles: circular mean of child angles (post-order)\n  (function setInternalAngles(id) {\n    const c = kids.get(id) || [];\n    for (const ch of c) setInternalAngles(ch);\n    if (c.length > 0) {\n      let sx = 0, sy = 0;\n      for (const ch of c) {\n        const th = angle.get(ch);\n        sx += Math.cos(th);\n        sy += Math.sin(th);\n      }\n      angle.set(id, norm(Math.atan2(sy, sx)));\n    }\n  })(root);\n\n  // Radii: cumulative branch lengths from root (root r=0)\n  const radius = new Map();\n  radius.set(root, 0);\n  (function setR(id) {\n    const c = kids.get(id) || [];\n    const r0 = radius.get(id) || 0;\n    for (const ch of c) {\n      const child = byId.get(ch);\n      const bl = child?.branchLength ?? 0;\n      radius.set(ch, r0 + bl);\n      setR(ch);\n    }\n  })(root);\n\n  // Enrich pd rows with angle, r, x, y\n  for (const d of pd) {\n    const th = angle.get(d.thisId) ?? 0;\n    const r  = radius.get(d.thisId) ?? 0;\n    d.angle = th;\n    d.r = r;\n    d.x = r * Math.cos(th);\n    d.y = r * Math.sin(th);\n  }\n\n  return pd;\n}\n","import radialData from \"./radialData.js\"\nimport getRadii from \"./getRadii.js\"\nimport getArcs from \"./getArcs.js\"\n\n/**\n * Simple wrapper for radial layout:\n *  - data: per-node { angle, r, x, y, ... }\n *  - radii: per-edge radial spokes (parent.r → child.r)\n *  - arcs: per-internal-node arcs spanning its children at parent radius\n */\nexport default function radialLayout(node) {\n  const data = {};\n  data.data = radialData(node);\n  data.radii = getRadii(node);\n  data.arcs = getArcs(data.data);\n  return data;\n}\n\n","import radialData from \"./radialData.js\";\n\n/**\n * Per-edge radial segments (for highlighting and drawing).\n * For each non-root node, draw a radial line from the parent radius to the child radius\n * at the CHILD'S angle.\n *\n * Output: [{ parentId, childId, x0, y0, x1, y1, isTip }]\n */\nexport default function getRadii(node) {\n  const data = radialData(node);\n  const byId = new Map(data.map(d => [d.thisId, d]));\n  const root = data.find(d => d.parentId == null)?.thisId;\n\n  const segments = [];\n  for (const d of data) {\n    if (d.thisId === root) continue;\n    const parent = byId.get(d.parentId);\n    if (!parent) continue;\n\n    const theta = d.angle;\n    const r0 = parent.r;\n    const r1 = d.r;\n\n    segments.push({\n      parentId: parent.thisId,\n      childId: d.thisId,\n      x0: r0 * Math.cos(theta),\n      y0: r0 * Math.sin(theta),\n      x1: r1 * Math.cos(theta),\n      y1: r1 * Math.sin(theta),\n      isTip: !!d.isTip\n    });\n  }\n  return segments;\n}\n\n","/**\n * Build arc descriptors for each internal parent:\n *  - One arc per internal node at radius = parent.r\n *  - Start/end angles choose the *shortest* wrap-aware span covering the children\n *  - Skips degenerate spans (delta ~ 0)\n */\nexport default function getArcs(pd) {\n  const TAU = Math.PI * 2;\n  const norm = (t) => ((t % TAU) + TAU) % TAU;\n  const EPS = 1e-6;\n\n  // Quick lookups\n  const byId = new Map(pd.map(d => [d.thisId, d]));\n  const childrenByParent = new Map();\n  let root = null;\n\n  for (const d of pd) {\n    if (d.parentId == null) root = d.thisId;\n    if (!childrenByParent.has(d.parentId)) childrenByParent.set(d.parentId, []);\n    childrenByParent.get(d.parentId).push(d);\n  }\n\n  const arcs = [];\n\n  for (const parent of pd) {\n    const pid = parent.thisId;\n    if (pid === root) continue; // no arc above root\n    const kids = childrenByParent.get(pid) || [];\n    if (kids.length < 2) continue; // need at least two children\n\n    // Collect & sort child angles\n    const A = kids.map(k => norm(k.angle)).sort((a, b) => a - b);\n    const aMin = A[0], aMax = A[A.length - 1];\n\n    // Two candidate spans: direct (aMin -> aMax) and wrapped (aMax -> aMin across 2π)\n    const direct = aMax - aMin;\n    const wrapped = TAU - direct;\n\n    // Choose the shorter span. We'll draw **CCW** (sweepFlag = 0) in describeArc.\n    let start, end, span;\n    if (direct <= wrapped) {\n      start = aMin;\n      end = aMax;\n      span = direct;\n    } else {\n      // wrapped is shorter: go CCW from aMax up through 2π to aMin\n      start = aMax;\n      end = aMin;\n      span = wrapped;\n    }\n\n    if (span < EPS || !isFinite(parent.r) || parent.r <= 0) continue;\n\n    arcs.push({\n      start,\n      end,\n      radius: parent.r,\n      thisId: pid,\n      parentId: parent.parentId\n    });\n  }\n\n  return arcs;\n}\n\n","import mean from \"../utils/mean.js\"\nimport fortify from \"../utils/fortify.js\"\n\n/**\n * Rectangle layout: compute per-node x0,x1 and y0=y1\n * - Tip y is assigned by input order (preserves ladderize/order)\n * - Internal node y is mean of child y's\n * - x1 accumulates branch lengths from root\n */\n\nexport default function getHorizontal(node) {\n  const pd = fortify(node);\n\n  // Fast lookup from id -> pd index\n  const idIndex = new Map(pd.map((d, i) => [d.thisId, i]));\n\n  // 1) Leaf order from the INPUT TREE (respects your child order / ladderize)\n  const leafIds = [];\n  (function dfs(n) {\n    if (!n.children || n.children.length === 0) { leafIds.push(n.id); return; }\n    n.children.forEach(dfs);\n  })(node);\n\n  // Map each leaf id to a vertical slot (1..N)\n  const tipSlot = new Map(leafIds.map((id, i) => [id, i + 1]));\n\n  // 2) Set Y for tips directly from that order; internal node Y via children mean\n  (function setY(n) {\n    const i = idIndex.get(n.id);\n    if (!n.children || n.children.length === 0) {\n      const y = tipSlot.get(n.id);\n      pd[i].y0 = y; pd[i].y1 = y;\n      return y;\n    }\n    const ys = n.children.map(setY);\n    const y = mean(ys);\n    pd[i].y0 = y; pd[i].y1 = y;\n    return y;\n  })(node);\n\n  // 3) Set X by accumulating branch lengths down the tree\n  (function setX(n, xParent) {\n    const i = idIndex.get(n.id);\n    const bl = pd[i].branchLength ?? 0;\n    const x0 = xParent ?? 0;\n    const x1 = x0 + bl;\n    pd[i].x0 = x0; pd[i].x1 = x1;\n    if (n.children && n.children.length) n.children.forEach(c => setX(c, x1));\n  })(node, 0);\n\n  // Clean up: remove fields not needed downstream without triggering no-unused-vars\n  return pd.map((row) => {\n    const { y: _y, x: _x, angle: _angle, ...item } = row;\n    return item;\n  });\n}\n\n","/**\n * Iterable mean\n * Poached from https://github.com/d3/d3-array/blob/master/src/mean.js\n * (Other array means buggered up the tree)\n */\n\nexport default function (values, valueof) {\n    let count = 0;\n    let sum = 0;\n    if (valueof === undefined) {\n        for (let value of values) {\n            if (value != null && (value = +value) >= value) {\n                ++count, sum += value;\n            }\n        }\n    } else {\n        let index = -1;\n        for (let value of values) {\n            if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n                ++count, sum += value;\n            }\n        }\n    }\n    if (count) return sum / count;\n}\n","import getHorizontal from \"./getHorizontal.js\"\nimport getVertical from \"./getVertical.js\"\nimport getChildVerticals from \"./getChildVerticals.js\"\n\n/**\n * Rectangle layout wrapper.\n * Returns:\n *  - data: per-node rows (x0,x1,y0=y1,...)\n *  - vertical_lines: single spanning vertical per parent (baseline draw)\n *  - child_vertical_lines: one vertical per edge (for highlighting)\n *  - horizontal_lines: per-edge child horizontals (x0->x1 at y), with labels & tip flags\n */\nexport default function rectangleLayout(node) {\n  const data = getHorizontal(node);              // per-node\n  const vertical_lines = getVertical(node);      // parent spans\n  const child_vertical_lines = getChildVerticals(node); // per-edge verticals\n\n  // IMPORTANT: include y0 & y1, and carry isTip/labels for the renderer\n  const byId = new Map(data.map(d => [d.thisId, d]));\n  const horizontal_lines = data\n    .filter(d => d.parentId != null)\n    .map(d => ({\n      parentId: d.parentId,\n      childId: d.thisId,\n      thisId: d.thisId,\n      thisLabel: d.thisLabel,\n      isTip: d.isTip,\n      x0: d.x0,\n      x1: d.x1,\n      y0: d.y0,\n      y1: d.y0\n    }));\n\n  return { data, vertical_lines, child_vertical_lines, horizontal_lines };\n}\n\n","import getHorizontal from \"./getHorizontal.js\"\n\nexport default function getVertical(node) {\n  const data = getHorizontal(node);\n\n  // Group rows by parentId (children that share a parent)\n  const byParent = new Map();\n  for (const row of data) {\n    if (row.parentId == null) continue;\n    const a = byParent.get(row.parentId);\n    if (a) a.push(row); else byParent.set(row.parentId, [row]);\n  }\n\n  const verticals = [];\n  for (const [parentId, kids] of byParent.entries()) {\n    if (!kids.length) continue;\n    // Works for binary and multifurcations:\n    const yvals = kids.map(d => d.y0);\n    const y0 = Math.min(...yvals);\n    const y1 = Math.max(...yvals);\n    // All children share the same junction x (their x0)\n    const x = kids[0].x0;\n\n    verticals.push({\n      parentId,\n      x0: x,\n      x1: x,\n      y0,\n      y1,\n      heights: y1 - y0\n    });\n  }\n\n  return verticals;\n}\n\n","import getHorizontal from \"./getHorizontal.js\";\n\n/**\n * Build per-child vertical segments for a rectangular tree:\n * For each non-root node (child), draw a vertical from (parent.x, child.y) to (parent.x, parent.y).\n * This yields exactly one vertical per edge (child->parent), making highlighting trivial.\n *\n * Returns an array of:\n *   {\n *     parentId: number,\n *     childId: number,\n *     x: number,         // x of the parent junction\n *     y0: number,        // min(child.y, parent.y)\n *     y1: number,        // max(child.y, parent.y)\n *   }\n */\nexport default function getChildVerticals(node) {\n  const data = getHorizontal(node); // has parentId, thisId, x0,x1,y0=y1\n\n  // Build a quick index to access parent's y by id\n  const byId = new Map(data.map(d => [d.thisId, d]));\n\n  const childVerticals = [];\n\n  for (const d of data) {\n    if (d.parentId == null) continue;\n    const parent = byId.get(d.parentId);\n    if (!parent) continue;\n\n    const x = d.x0;            // child’s vertical sits at parent.x == child.x0\n    const yc = d.y0;           // child y\n    const yp = parent.y0;      // parent y\n    const y0 = Math.min(yc, yp);\n    const y1 = Math.max(yc, yp);\n\n    childVerticals.push({\n      parentId: d.parentId,\n      childId: d.thisId,\n      x,\n      y0,\n      y1\n    });\n  }\n\n  return childVerticals;\n}\n\n","import numTips from \"../utils/numTips.js\"\n\n/**\n * Equal-angle layout for unrooted trees.\n * - Precomputes ntips in O(n) to avoid repeated subtree counts\n * - Uses angles in \"π units\" (0..2) to match existing API\n * - Populates x,y positions from branchLength and angle\n */\n\nfunction annotateTipCounts(root) {\n  (function post(n) {\n    if (!n.children || n.children.length === 0) {\n      n.ntips = 1; return 1;\n    }\n    let sum = 0;\n    for (const c of n.children) sum += post(c);\n    n.ntips = sum;\n    return sum;\n  })(root);\n  return root;\n}\n\nfunction equalAngleLayout(node) {\n  if (node.parent === null) {\n    annotateTipCounts(node);\n    node.start = 0.;     // guarantees no arcs overlap 0\n    node.end = 2.;       // *π\n    node.angle = 0.;     // irrelevant at root\n    node.ntips = numTips(node); // safe (already computed), left for compatibility\n    node.x = 0;\n    node.y = 0;\n  }\n\n  let lastStart = node.start;\n\n  for (let i = 0; i < node.children.length; i++) {\n    const child = node.children[i];\n    const arc = (node.end - node.start) * (child.ntips / node.ntips);\n\n    child.start = lastStart;\n    child.end = lastStart + arc;\n\n    // bisect the arc in π-units\n    child.angle = child.start + (child.end - child.start) / 2.;\n    lastStart = child.end;\n\n    // map to coordinates (convert π-units to radians by multiplying by Math.PI)\n    const theta = child.angle * Math.PI;\n    const bl = (child.branchLength ?? 0);\n    child.x = node.x + bl * Math.sin(theta);\n    child.y = node.y + bl * Math.cos(theta);\n\n    equalAngleLayout(child);\n  }\n\n  return node;\n}\n\nexport default equalAngleLayout\n\n","/**\n * Recursive function for breadth-first search of a tree\n * the root node is visited first.\n */\n\nfunction levelorder(root) {\n  const queue = [root], result = [];\n  while (queue.length) {\n    const curnode = queue.shift();         // <- FIFO\n    result.push(curnode);\n    for (const child of curnode.children) queue.push(child);\n  }\n  return result;\n}\n\n\n/**\n * Count the number of tips that descend from this node\n */\n\nexport default function(thisnode) {\n  var result = 0;\n  for (const node of levelorder(thisnode)) {\n    if (node.children.length == 0) result++;\n  }\n  return (result);\n}\n","import edges from \"../utils/edges.js\";\nimport fortify from \"../utils/fortify.js\";\nimport equalAngleLayout from \"./equalAngleLayout.js\";\n\n/**\n * Simple wrapper function for equalAngleLayout()\n */\n\nexport default function (node) {\n  var data = {};\n  // use the Felsenstein equal angle layout algorithm\n  var eq = fortify(equalAngleLayout(node));\n  data.data = eq;\n  // make the edges dataset\n  data.edges = edges(eq);\n\n  return data;\n}\n","/**\n * Convert parsed Newick tree from fortify() into data frame of edges\n * this is akin to a \"phylo\" object in R, where thisID and parentId\n * are the $edge slot. I think.\n */\n\nexport default function edges(df, rectangular = false) {\n  const rows = [...df].sort((a, b) => a.thisId - b.thisId);\n  const byId = new Map(rows.map((r) => [r.thisId, r]));\n  const result = [];\n\n  for (const row of rows) {\n    if (row.parentId == null) continue;\n    const parent = byId.get(row.parentId);\n    if (!parent) continue;\n\n    if (rectangular) {\n      result.push({ x1: row.x, y1: row.y, id1: row.thisId, x2: parent.x, y2: row.y, id2: undefined });\n      result.push({ x1: parent.x, y1: row.y, id1: undefined, x2: parent.x, y2: parent.y, id2: row.parentId });\n    } else {\n      result.push({ x1: row.x, y1: row.y, id1: row.thisId, x2: parent.x, y2: parent.y, id2: row.parentId });\n    }\n  }\n  return result;\n}\n\n","export function makeIndexById(rows, key = \"thisId\") {\n  return new Map(rows.map(d => [d[key], d]));\n}\nexport default function parentFisheye(d, data) {\n  const byId = makeIndexById(data);\n  const parent = byId.get(d.parentId);\n  return parent ? { px: parent.fisheye.x, py: parent.fisheye.y } : null;\n}\n\n","/**\n * Parse a Newick tree string into a doubly-linked list of JS Objects.\n * Assigns labels, branch lengths, and node IDs (tips before internals if input emits them that way).\n *\n * Notes / limitations:\n * - Quoted labels and NHX annotations are not fully supported.\n * - Branch lengths in scientific notation are supported (parseFloat).\n */\n\nexport default function readTree(text) {\n  // Remove all whitespace (space, tabs, newlines)\n  text = String(text).replace(/\\s+/g, '');\n\n  const tokens = text.split(/(;|\\(|\\)|,)/);\n  const root = { parent: null, children: [] };\n  let curnode = root;\n  let nodeId = 0;\n\n  for (const token of tokens) {\n    if (!token || token === ';') continue;\n\n    if (token === '(') {\n      const child = { parent: curnode, children: [] };\n      curnode.children.push(child);\n      curnode = child; // descend\n    } else if (token === ',') {\n      // back to parent, then create sibling\n      curnode = curnode.parent;\n      const child = { parent: curnode, children: [] };\n      curnode.children.push(child);\n      curnode = child;\n    } else if (token === ')') {\n      // ascend one level\n      curnode = curnode.parent;\n      if (curnode === null) break;\n    } else {\n      // label/branch-length chunk (e.g., \"A:0.01\" or \"A\")\n      const nodeinfo = token.split(':');\n      if (nodeinfo.length === 1) {\n        if (token.startsWith(':')) {\n          curnode.label = '';\n          curnode.branchLength = parseFloat(nodeinfo[0]);\n        } else {\n          curnode.label = nodeinfo[0];\n          curnode.branchLength = null;\n        }\n      } else if (nodeinfo.length === 2) {\n        curnode.label = nodeinfo[0];\n        curnode.branchLength = parseFloat(nodeinfo[1]);\n      } else {\n        console.warn(token, \"Unhandled token with multiple ':' characters\");\n        curnode.label = nodeinfo[0] || '';\n        curnode.branchLength = parseFloat(nodeinfo[nodeinfo.length - 1]);\n      }\n      curnode.id = nodeId++; // assign then increment\n    }\n  }\n\n  // Ensure root has an id if not assigned during parsing\n  if (root.id == null) root.id = nodeId;\n\n  return root;\n}\n\n","/** \n* Subset a tree given a node - i.e. the node of interests and all the descendents\n*/\n\nexport default function (tree, node) {\n    // Thanks Richard Challis!\n    let fullTree = {};\n    tree.data.forEach(obj => {\n        fullTree[obj.thisId] = { ...obj };\n    });\n\n    let subTree = {};\n    const getDescendants = function (rootNodeId) {\n        if (fullTree[rootNodeId]) {\n            subTree[rootNodeId] = fullTree[rootNodeId];\n            if (fullTree[rootNodeId].children) {\n                fullTree[rootNodeId].children.forEach(childNodeId => {\n                    getDescendants(childNodeId);\n                });\n            }\n        }\n    };\n    // call the recursive function\n    getDescendants(node);\n\n    // in each of the functions, data contains the children key\n    const data = [[\"data\", Object.values(subTree)]];\n\n    const nodes = data[0][1].map(d => d.thisId);\n\n    var res = [];\n    // in all keys except data, push to new array\n    for (const node in tree) {\n        if (node === \"data\") continue;\n        res.push([node, tree[node]]);\n    }\n\n    var filtered = res.map(d => [\n        d[0],\n        d[1].filter(d => nodes.includes(d.thisId))\n    ]);\n\n    return Object.fromEntries(data.concat(filtered));\n}\n"],"names":["phisheye","circular","radius","distortion","focus","scales","k0","k1","radius2","zClamp","rescale","e","Math","exp","fisheye","d","xscale","yscale","Error","ensureScales","x0","x","y0","y","dx","dy","dd2","z","dd","sqrt","k","min","_","arguments","length","max","slice","Array","isArray","setScales","clampZ","focusFromEvent","event","element","rect","getBoundingClientRect","fx","clientX","left","fy","clientY","top","describeArc","cx","cy","startAngle","endAngle","TAU","PI","norm","t","a0","a1","ccw","cw","sweepFlag","delta","largeArcFlag","p","polarToCartesian","p0","p1","start","end","join","preorder","node","list","push","i","children","fortify","tree","sort","df","parent","parentId","parentLabel","thisId","id","thisLabel","label","map","branchLength","isTip","angle","a","b","radialData","pd","byId","Map","kids","root","tipIds","dfs","c","get","ch","N","forEach","set","setInternalAngles","sx","sy","th","cos","sin","atan2","setR","r0","child","bl","r","radialLayout","data","radii","find","segments","theta","r1","childId","x1","y1","getRadii","arcs","childrenByParent","has","pid","A","aMin","aMax","direct","wrapped","span","isFinite","getArcs","getHorizontal","idIndex","leafIds","n","tipSlot","setY","values","count","sum","value","mean","setX","xParent","row","_y","_x","_angle","item","rectangleLayout","vertical_lines","byParent","verticals","entries","yvals","heights","getVertical","child_vertical_lines","childVerticals","yc","yp","getChildVerticals","horizontal_lines","filter","equalAngleLayout","post","ntips","thisnode","result","queue","curnode","shift","levelorder","numTips","lastStart","arc","unrooted","eq","edges","rectangular","rows","id1","x2","y2","id2","undefined","parentFisheye","key","makeIndexById","px","py","readTree","text","tokens","String","replace","split","nodeId","token","nodeinfo","startsWith","parseFloat","console","warn","subTree","fullTree","obj","getDescendants","rootNodeId","childNodeId","Object","nodes","res","filtered","includes","fromEntries","concat"],"mappings":"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"}